"""CLI handlers for CVE/vulnerability operations."""

from typing import Optional, Dict, Any
import requests
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn

from dav.vulnerability.scanner import VulnerabilityScanner
from dav.vulnerability.nvd_client import NVDClient
from dav.config import get_nvd_api_key
from dav.terminal import (
    render_info,
    render_warning,
    render_error,
    render_success,
    render_streaming_response_with_loading,
)
from dav.ai_backend import FailoverAIBackend
from dav.session import SessionManager
from dav.context import build_context
from dav.executor import COMMAND_EXECUTION_MARKER, execute_commands_from_response

console = Console()


def handle_cve_command(
    cve_arg: str,
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """
    Handle CVE-related commands.
    
    Args:
        cve_arg: CVE command argument (scan, scan-core, CVE-ID, or package:name)
        execute: Whether to execute remediation commands
        auto_confirm: Auto-confirm execution
        automation: Automation mode
    """
    cve_arg_lower = cve_arg.lower().strip()
    
    # Internal test mode (undocumented, for troubleshooting)
    if cve_arg_lower.startswith("test:"):
        test_cpe = cve_arg[5:].strip()
        _test_cpe_query(test_cpe)
        return
    
    if cve_arg_lower == "scan" or cve_arg_lower == "":
        handle_system_scan(execute=execute, auto_confirm=auto_confirm, automation=automation)
    elif cve_arg_lower == "scan-core":
        handle_system_scan(core_only=True, execute=execute, auto_confirm=auto_confirm, automation=automation)
    else:
        # Treat any other input as a query for AI analysis after scan
        handle_system_scan_with_query(
            cve_arg,
            execute=execute,
            auto_confirm=auto_confirm,
            automation=automation
        )


def handle_system_scan(
    core_only: bool = False,
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """Handle system-wide vulnerability scan."""
    api_key = get_nvd_api_key()
    scanner = VulnerabilityScanner(nvd_api_key=api_key)
    
    # Show initial info
    scan_type = "Core Security Packages" if core_only else "System Packages"
    console.print(Panel.fit(
        f"[bold cyan]Vulnerability Scanner[/bold cyan]\n"
        f"[dim]Scanning {scan_type.lower()} against NVD database[/dim]",
        border_style="cyan"
    ))
    console.print()
    
    if core_only:
        render_info("Scanning only core security-critical packages (OpenSSL, SSH, system libraries, etc.)")
        console.print()
    
    # Show rate limit info
    rate_info = scanner.nvd_client.get_rate_limit_info()
    tier_text = "paid tier" if rate_info["tier"] == "paid" else "free tier"
    render_info(
        f"Using NVD API {tier_text} "
        f"({rate_info['limit']} requests per {rate_info['window_seconds']} seconds)"
    )
    console.print()
    
    # Perform scan with progress
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
        TextColumn("({task.completed}/{task.total})"),
        TimeElapsedColumn(),
        console=console
    ) as progress:
        task = progress.add_task("Scanning packages...", total=100)
        
        def progress_callback(current: int, total: int, package_name: str):
            percentage = int((current / total) * 100) if total > 0 else 0
            progress.update(
                task,
                completed=percentage,
                total=100,
                description=f"Scanning {package_name[:30]}... ({current}/{total} packages)"
            )
        
        results = scanner.scan_system(progress_callback=progress_callback, core_only=core_only)
    
    # Display results
    _display_scan_results(results, execute=execute, auto_confirm=auto_confirm)
    
    # Show cache info
    cache_size = scanner.cache.get_cache_size()
    cache_dir = scanner.cache.cache_dir
    if cache_size > 0:
        render_info(f"Cache: {cache_size} entries stored in {cache_dir}")
        console.print(f"[dim]Note: Empty cache entries (data: []) mean the API call succeeded but no CVEs were found.[/dim]")
        console.print(f"[yellow][dim]Important: Python/pip packages are often not in NVD database.[/dim][/yellow]")
        console.print(f"[dim]NVD focuses on system software (OS components, servers, etc.), not Python libraries.[/dim]")
        console.print(f"[dim]For Python packages, consider using OSV (Open Source Vulnerabilities) database instead.[/dim]")
    else:
        render_warning(f"Cache: No entries found in {cache_dir} (check write permissions)")


def handle_system_scan_with_query(
    query: str,
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """Handle system scan with AI analysis of results."""
    # Perform scan first
    api_key = get_nvd_api_key()
    scanner = VulnerabilityScanner(nvd_api_key=api_key)
    
    console.print(Panel.fit(
        "[bold cyan]Vulnerability Scan with AI Analysis[/bold cyan]\n"
        "[dim]Scanning system and analyzing results[/dim]",
        border_style="cyan"
    ))
    
    render_info(f"Query: {query}")
    console.print()
    
    # Show rate limit info
    rate_info = scanner.nvd_client.get_rate_limit_info()
    tier_text = "paid tier" if rate_info["tier"] == "paid" else "free tier"
    render_info(
        f"Using NVD API {tier_text} "
        f"({rate_info['limit']} requests per {rate_info['window_seconds']} seconds)"
    )
    render_warning("Scanning may take several minutes due to API rate limits.")
    console.print()
    
    # Perform scan with progress
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
        TextColumn("({task.completed}/{task.total})"),
        TimeElapsedColumn(),
        console=console
    ) as progress:
        task = progress.add_task("Scanning packages...", total=100)
        
        def progress_callback(current: int, total: int, package_name: str):
            percentage = int((current / total) * 100) if total > 0 else 0
            progress.update(
                task,
                completed=percentage,
                total=100,
                description=f"Scanning {package_name[:30]}... ({current}/{total} packages)"
            )
        
        scan_results = scanner.scan_system(progress_callback=progress_callback)
    
    # Format results for AI
    scan_summary = _format_scan_for_ai(scan_results)
    
    # Send to AI for analysis
    render_info("\n[bold]Analyzing scan results with AI...[/bold]\n")
    
    # Build AI prompt
    ai_query = f"""
{query}

Here are the vulnerability scan results from my system:

{scan_summary}

Please analyze these results and provide:
1. A summary of the security posture
2. Prioritized recommendations
3. Specific actions I should take
"""
    
    # Initialize AI backend
    try:
        ai_backend = FailoverAIBackend()
        session_manager = SessionManager()
        
        # Build prompt with context (duplicate logic from cli.py to avoid circular import)
        from dav.context import build_context, format_context_for_prompt
        from dav.ai_backend import get_system_prompt
        
        context_data = build_context(query=ai_query, stdin_content=None)
        context_str = format_context_for_prompt(context_data)
        
        session_context = session_manager.get_conversation_context()
        if session_context:
            context_str = session_context + "\n" + context_str
        
        system_prompt = get_system_prompt(execute_mode=execute, interactive_mode=False, automation_mode=automation)
        full_prompt = context_str
        
        # Get AI response
        backend_name = ai_backend.backend.title()
        response = render_streaming_response_with_loading(
            ai_backend.stream_response(full_prompt, system_prompt=system_prompt),
            loading_message=f"Analyzing vulnerabilities with {backend_name}...",
        )
        
        # Display AI response
        console.print("\n" + response + "\n")
        
        # If execute mode, process any commands in response
        if execute:
            if COMMAND_EXECUTION_MARKER in response:
                execute_commands_from_response(
                    response,
                    confirm=not auto_confirm,
                    context=context_data,
                    automation_mode=automation
                )
    except Exception as e:
        render_error(f"Error during AI analysis: {str(e)}")
        console.print_exception()
        # Still show scan results even if AI analysis failed
        _display_scan_results(scan_results, execute=execute, auto_confirm=auto_confirm)
    
    # Show cache info
    cache_size = scanner.cache.get_cache_size()
    cache_dir = scanner.cache.cache_dir
    if cache_size > 0:
        render_info(f"Cache: {cache_size} entries stored in {cache_dir}")
        console.print(f"[dim]Note: Empty cache entries (data: []) mean the API call succeeded but no CVEs were found.[/dim]")
        console.print(f"[yellow][dim]Important: Python/pip packages are often not in NVD database.[/dim][/yellow]")
        console.print(f"[dim]NVD focuses on system software (OS components, servers, etc.), not Python libraries.[/dim]")
        console.print(f"[dim]For Python packages, consider using OSV (Open Source Vulnerabilities) database instead.[/dim]")
    else:
        render_warning(f"Cache: No entries found in {cache_dir} (check write permissions)")


def _display_scan_results(
    results: Dict[str, Any],
    execute: bool = False,
    auto_confirm: bool = False
) -> None:
    """Display scan results in a formatted table."""
    if results["status"] != "success":
        render_error(f"Scan failed: {results.get('message', 'Unknown error')}")
        return
    
    summary = results["summary"]
    vulns = results["vulnerabilities"]
    stats = results.get("statistics", {})
    
    # Statistics panel
    stats_text = (
        f"[bold]Packages Processed:[/bold] {results['total_packages_scanned']}\n"
    )
    
    if stats:
        stats_text += f"[bold]API Calls:[/bold] {stats.get('api_calls_made', 0)} made, "
        stats_text += f"[green]{stats.get('api_calls_succeeded', 0)} succeeded[/green], "
        stats_text += f"[red]{stats.get('api_calls_failed', 0)} failed[/red]\n"
        stats_text += f"[bold]Cache:[/bold] [green]{stats.get('cache_hits', 0)} hits[/green], "
        stats_text += f"[yellow]{stats.get('cache_misses', 0)} misses[/yellow]\n"
        if stats.get('packages_skipped', 0) > 0:
            stats_text += f"[bold]Skipped:[/bold] {stats.get('packages_skipped', 0)} packages (no CPE mapping)\n"
    
    console.print(Panel(stats_text, title="[bold]Scan Statistics[/bold]", border_style="blue"))
    console.print()
    
    # Show errors if any
    if stats.get('errors'):
        error_count = len(stats['errors'])
        if error_count > 0:
            render_warning(f"Encountered {error_count} API error(s) during scan:")
            console.print()
            
            # Group errors by type for better readability
            from collections import Counter
            error_types = Counter()
            error_examples = {}
            
            for error in stats['errors']:
                # Extract error type (last part after colon)
                if ':' in error:
                    error_msg = error.split(':', 1)[1].strip()
                    error_types[error_msg] += 1
                    if error_msg not in error_examples:
                        error_examples[error_msg] = error.split(':', 1)[0].strip()
            
            # Show grouped errors
            for error_msg, count in error_types.most_common(5):
                package_example = error_examples.get(error_msg, "package")
                if count == 1:
                    console.print(f"  [dim]• {package_example}: {error_msg}[/dim]")
                else:
                    console.print(f"  [dim]• {error_msg} ({count} packages, e.g., {package_example})[/dim]")
            
            if error_count > 5:
                console.print(f"  [dim]... and {error_count - len(error_types)} more errors[/dim]")
            console.print()
            
            # Provide helpful suggestions
            if any("Rate limit" in e for e in stats['errors']):
                render_info("Tip: Consider using a paid NVD API key to increase rate limits")
            if any("Connection" in e or "timeout" in e.lower() for e in stats['errors']):
                render_info("Tip: Network issues detected. Check your internet connection.")
            console.print()
    
    # Summary panel
    summary_text = (
        f"[bold]Vulnerabilities Found:[/bold] {results['vulnerabilities_found']}\n\n"
        f"[red]Critical:[/red] {summary['critical']}  "
        f"[yellow]High:[/yellow] {summary['high']}  "
        f"[cyan]Medium:[/cyan] {summary['medium']}  "
        f"[dim]Low:[/dim] {summary['low']}"
    )
    
    console.print(Panel(summary_text, title="[bold]Vulnerability Summary[/bold]", border_style="cyan"))
    console.print()
    
    if not vulns:
        render_success("No vulnerabilities found in scanned packages!")
        # Add note about scan quality
        if stats.get('api_calls_failed', 0) > 0:
            render_warning(
                f"Note: {stats.get('api_calls_failed', 0)} API call(s) failed. "
                "Some packages may not have been checked properly."
            )
        return
    
    # Vulnerabilities table
    table = Table(title="[bold]Vulnerabilities[/bold]", show_header=True, header_style="bold cyan")
    table.add_column("CVE ID", style="cyan", no_wrap=True)
    table.add_column("Package", style="green")
    table.add_column("Version", style="dim")
    table.add_column("Severity", justify="center")
    table.add_column("CVSS", justify="right")
    
    # Show top 20
    for vuln in vulns[:20]:
        severity = vuln["severity"]
        severity_color = {
            "CRITICAL": "red",
            "HIGH": "yellow",
            "MEDIUM": "cyan",
            "LOW": "dim"
        }.get(severity, "white")
        
        table.add_row(
            vuln["cve_id"],
            vuln["package"],
            vuln["package_version"],
            f"[{severity_color}]{severity}[/{severity_color}]",
            f"{vuln['cvss_score']:.1f}"
        )
    
    console.print(table)
    console.print()
    
    if len(vulns) > 20:
        render_info(f"... and {len(vulns) - 20} more vulnerabilities. Use --execute for full report.")
    
    # Show remediation if execute mode
    if execute:
        _suggest_remediation(vulns, auto_confirm=auto_confirm)


def _format_scan_for_ai(scan_results: Dict[str, Any]) -> str:
    """Format scan results in a way that's useful for AI analysis."""
    if scan_results["status"] != "success":
        return f"Scan failed: {scan_results.get('message', 'Unknown error')}"
    
    summary = scan_results["summary"]
    vulns = scan_results["vulnerabilities"]
    
    output = []
    output.append("## Vulnerability Scan Results")
    output.append("")
    output.append(f"**System Information:**")
    output.append(f"- Packages Scanned: {scan_results['total_packages_scanned']}")
    output.append(f"- Vulnerabilities Found: {scan_results['vulnerabilities_found']}")
    output.append("")
    output.append("**Severity Breakdown:**")
    output.append(f"- Critical: {summary['critical']}")
    output.append(f"- High: {summary['high']}")
    output.append(f"- Medium: {summary['medium']}")
    output.append(f"- Low: {summary['low']}")
    output.append("")
    
    if vulns:
        output.append("**Vulnerabilities:**")
        output.append("")
        
        # Show all vulnerabilities (or top 50 for very large lists)
        for idx, vuln in enumerate(vulns[:50], 1):
            output.append(f"### {idx}. {vuln['cve_id']}")
            output.append(f"- **Package:** {vuln['package']} (version: {vuln['package_version']})")
            output.append(f"- **Severity:** {vuln['severity']} (CVSS: {vuln['cvss_score']:.1f})")
            output.append(f"- **Published:** {vuln['published_date']}")
            output.append(f"- **Description:** {vuln['description'][:300]}...")
            if vuln.get('references'):
                refs = vuln['references'][:3]
                output.append(f"- **References:** {', '.join(refs)}")
            output.append("")
        
        if len(vulns) > 50:
            output.append(f"... and {len(vulns) - 50} more vulnerabilities")
    
    return "\n".join(output)


def _suggest_remediation(vulnerabilities: list, auto_confirm: bool = False) -> None:
    """Suggest remediation steps for vulnerabilities."""
    if not vulnerabilities:
        return
    
    render_info("\n[bold]Remediation Suggestions:[/bold]")
    
    # Group by package
    by_package = {}
    for vuln in vulnerabilities:
        pkg = vuln["package"]
        if pkg not in by_package:
            by_package[pkg] = []
        by_package[pkg].append(vuln)
    
    # Show upgrade commands
    console.print("\n[bold]Recommended Actions:[/bold]\n")
    
    for package, vulns in list(by_package.items())[:10]:  # Top 10 packages
        highest_severity = max(vulns, key=lambda x: x.get("cvss_score", 0))
        
        console.print(f"[cyan]{package}[/cyan] - {len(vulns)} vulnerability/vulnerabilities")
        console.print(f"  Highest severity: {highest_severity['severity']} (CVSS: {highest_severity['cvss_score']:.1f})")
        console.print(f"  [dim]Recommendation: Check for available updates[/dim]\n")


def _test_cpe_query(cpe_string: str) -> None:
    """Internal test function for CPE queries (undocumented, for troubleshooting)."""
    from dav.vulnerability.nvd_client import NVDClient
    from dav.config import get_nvd_api_key
    
    console.print(Panel.fit(
        f"[bold cyan]CPE Query Test[/bold cyan]\n"
        f"[dim]CPE: {cpe_string}[/dim]",
        border_style="cyan"
    ))
    console.print()
    
    api_key = get_nvd_api_key()
    client = NVDClient(api_key=api_key)
    
    render_info(f"Querying NVD API...")
    console.print()
    
    cves, error = client.search_by_cpe(cpe_string, results_per_page=20)
    
    if error:
        render_error(f"Error: {error}")
    else:
        if cves:
            render_success(f"Found {len(cves)} CVE(s)!")
            console.print()
            
            # Show first few CVEs
            table = Table(title="CVEs Found")
            table.add_column("CVE ID", style="cyan")
            table.add_column("Published", style="dim")
            table.add_column("Description", style="white", max_width=60)
            
            for cve in cves[:10]:
                cve_id = cve.get("id", "Unknown")
                published = cve.get("published", "Unknown")
                
                # Get description
                descriptions = cve.get("descriptions", [])
                description = "No description"
                if descriptions:
                    for desc in descriptions:
                        if desc.get("lang") == "en":
                            description = desc.get("value", "No description")[:100]
                            break
                
                table.add_row(cve_id, published, description)
            
            console.print(table)
            
            if len(cves) > 10:
                console.print(f"\n[dim]... and {len(cves) - 10} more CVEs[/dim]")
        else:
            render_warning("No CVEs found for this CPE")
            console.print()
            render_info("Possible reasons:")
            console.print("  • Package has no known vulnerabilities")
            console.print("  • CPE format doesn't match NVD database")
            console.print("  • Python/pip packages are typically not in NVD")
            console.print("    (NVD focuses on system software)")
