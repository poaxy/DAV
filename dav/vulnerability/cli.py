"""CLI handlers for CVE/vulnerability operations."""

from typing import Optional, Dict, Any
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn

from dav.vulnerability.scanner import VulnerabilityScanner
from dav.config import get_nvd_api_key
from dav.terminal import (
    render_info,
    render_warning,
    render_error,
    render_success,
    render_streaming_response_with_loading,
)
from dav.ai_backend import FailoverAIBackend
from dav.session import SessionManager
from dav.context import build_context
from dav.executor import COMMAND_EXECUTION_MARKER, execute_commands_from_response

console = Console()


def _perform_scan_with_progress(scanner: VulnerabilityScanner, core_only: bool = False) -> Dict[str, Any]:
    """Perform vulnerability scan with progress indicator."""
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
        TextColumn("({task.completed}/{task.total})"),
        TimeElapsedColumn(),
        console=console
    ) as progress:
        task = progress.add_task("Scanning packages...", total=100)
        
        def progress_callback(current: int, total: int, package_name: str):
            percentage = int((current / total) * 100) if total > 0 else 0
            progress.update(
                task,
                completed=percentage,
                total=100,
                description=f"Scanning {package_name[:30]}... ({current}/{total} packages)"
            )
        
        return scanner.scan_system(progress_callback=progress_callback, core_only=core_only)


def handle_cve_command(
    cve_arg: str,
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """
    Handle CVE-related commands.
    
    Args:
        cve_arg: CVE command argument (scan, scan-core, CVE-ID, or package:name)
        execute: Whether to execute remediation commands
        auto_confirm: Auto-confirm execution
        automation: Automation mode
    """
    cve_arg_lower = cve_arg.lower().strip()
    
    # Internal test mode (undocumented, for troubleshooting)
    if cve_arg_lower.startswith("test:"):
        test_cpe = cve_arg[5:].strip()
        _test_cpe_query(test_cpe)
        return
    
    if cve_arg_lower == "scan" or cve_arg_lower == "":
        handle_system_scan(execute=execute, auto_confirm=auto_confirm, automation=automation)
    elif cve_arg_lower == "scan-core":
        handle_system_scan(core_only=True, execute=execute, auto_confirm=auto_confirm, automation=automation)
    else:
        # Treat any other input as a query for AI analysis after scan
        handle_system_scan_with_query(
            cve_arg,
            execute=execute,
            auto_confirm=auto_confirm,
            automation=automation
        )


def handle_system_scan(
    core_only: bool = False,
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """Handle system-wide vulnerability scan."""
    api_key = get_nvd_api_key()
    scanner = VulnerabilityScanner(nvd_api_key=api_key)
    
    # Show initial info
    scan_type = "Core Security Packages" if core_only else "System Packages"
    console.print(Panel.fit(
        f"[bold cyan]Vulnerability Scanner[/bold cyan]\n"
        f"[dim]Scanning {scan_type.lower()} against NVD database[/dim]",
        border_style="cyan"
    ))
    console.print()
    
    if core_only:
        render_info("Scanning only core security-critical packages (OpenSSL, SSH, system libraries, etc.)")
        console.print()
    
    # Show rate limit info
    rate_info = scanner.nvd_client.get_rate_limit_info()
    tier_text = "paid tier" if rate_info["tier"] == "paid" else "free tier"
    render_info(
        f"Using NVD API {tier_text} "
        f"({rate_info['limit']} requests per {rate_info['window_seconds']} seconds)"
    )
    console.print()
    
    # Perform scan with progress
    results = _perform_scan_with_progress(scanner, core_only=core_only)
    
    # Display results
    _display_scan_results(results, execute=execute, auto_confirm=auto_confirm)
    
    # If vulnerabilities found, get AI suggestions for remediation
    if results.get("status") == "success" and results.get("vulnerabilities_found", 0) > 0:
        _get_ai_remediation_suggestions(results, execute=execute, auto_confirm=auto_confirm, automation=automation)
    
    # Show cache info only if there's an issue
    cache_size = scanner.cache.get_cache_size()
    if cache_size == 0:
        cache_dir = scanner.cache.cache_dir
        render_warning(f"Cache: No entries found in {cache_dir} (check write permissions)")


def handle_system_scan_with_query(
    query: str,
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """Handle system scan with AI analysis of results."""
    # Perform scan first
    api_key = get_nvd_api_key()
    scanner = VulnerabilityScanner(nvd_api_key=api_key)
    
    console.print(Panel.fit(
        "[bold cyan]Vulnerability Scan with AI Analysis[/bold cyan]\n"
        "[dim]Scanning system and analyzing results[/dim]",
        border_style="cyan"
    ))
    
    render_info(f"Query: {query}")
    console.print()
    
    # Show rate limit info
    rate_info = scanner.nvd_client.get_rate_limit_info()
    tier_text = "paid tier" if rate_info["tier"] == "paid" else "free tier"
    render_info(
        f"Using NVD API {tier_text} "
        f"({rate_info['limit']} requests per {rate_info['window_seconds']} seconds)"
    )
    render_warning("Scanning may take several minutes due to API rate limits.")
    console.print()
    
    # Perform scan with progress
    scan_results = _perform_scan_with_progress(scanner, core_only=False)
    
    # Format results for AI
    scan_summary = _format_scan_for_ai(scan_results)
    
    # Send to AI for analysis
    render_info("\n[bold]Analyzing scan results with AI...[/bold]\n")
    
    # Build AI prompt
    ai_query = f"""
{query}

Here are the vulnerability scan results from my system:

{scan_summary}

Please analyze these results and provide:
1. A summary of the security posture
2. Prioritized recommendations
3. Specific actions I should take
"""
    
    # Initialize AI backend
    try:
        ai_backend = FailoverAIBackend()
        session_manager = SessionManager()
        
        # Build prompt with context
        from dav.context import format_context_for_prompt
        from dav.ai_backend import get_system_prompt
        
        context_data = build_context(query=ai_query, stdin_content=None)
        context_str = format_context_for_prompt(context_data)
        
        session_context = session_manager.get_conversation_context()
        if session_context:
            context_str = session_context + "\n" + context_str
        
        system_prompt = get_system_prompt(execute_mode=execute, interactive_mode=False, automation_mode=automation)
        full_prompt = context_str
        
        # Get AI response
        backend_name = ai_backend.backend.title()
        response = render_streaming_response_with_loading(
            ai_backend.stream_response(full_prompt, system_prompt=system_prompt),
            loading_message=f"Analyzing vulnerabilities with {backend_name}...",
        )
        
        # Display AI response
        console.print("\n" + response + "\n")
        
        # If execute mode, process any commands in response
        if execute:
            if COMMAND_EXECUTION_MARKER in response:
                execute_commands_from_response(
                    response,
                    confirm=not auto_confirm,
                    context=context_data,
                    automation_mode=automation
                )
    except Exception as e:
        render_error(f"Error during AI analysis: {str(e)}")
        console.print_exception()
        # Still show scan results even if AI analysis failed
        _display_scan_results(scan_results, execute=execute, auto_confirm=auto_confirm)
    
    # Show cache info only if there's an issue
    cache_size = scanner.cache.get_cache_size()
    if cache_size == 0:
        cache_dir = scanner.cache.cache_dir
        render_warning(f"Cache: No entries found in {cache_dir} (check write permissions)")


def _display_scan_results(
    results: Dict[str, Any],
    execute: bool = False,
    auto_confirm: bool = False
) -> None:
    """Display scan results in a formatted table."""
    if results["status"] != "success":
        render_error(f"Scan failed: {results.get('message', 'Unknown error')}")
        return
    
    summary = results["summary"]
    vulns = results["vulnerabilities"]
    stats = results.get("statistics", {})
    
    # Statistics panel
    stats_text = (
        f"[bold]Packages Processed:[/bold] {results['total_packages_scanned']}\n"
    )
    
    if stats:
        stats_text += f"[bold]API Calls:[/bold] {stats.get('api_calls_made', 0)} made, "
        stats_text += f"[green]{stats.get('api_calls_succeeded', 0)} succeeded[/green], "
        stats_text += f"[red]{stats.get('api_calls_failed', 0)} failed[/red]\n"
        stats_text += f"[bold]Cache:[/bold] [green]{stats.get('cache_hits', 0)} hits[/green], "
        stats_text += f"[yellow]{stats.get('cache_misses', 0)} misses[/yellow]\n"
        if stats.get('packages_skipped', 0) > 0:
            stats_text += f"[bold]Skipped:[/bold] {stats.get('packages_skipped', 0)} packages (no CPE mapping)\n"
    
    console.print(Panel(stats_text, title="[bold]Scan Statistics[/bold]", border_style="blue"))
    console.print()
    
    # Show errors if any
    if stats.get('errors'):
        error_count = len(stats['errors'])
        if error_count > 0:
            render_warning(f"Encountered {error_count} API error(s) during scan:")
            console.print()
            
            # Group errors by type for better readability
            from collections import Counter
            error_types = Counter()
            error_examples = {}
            
            for error in stats['errors']:
                # Extract error type (last part after colon)
                if ':' in error:
                    error_msg = error.split(':', 1)[1].strip()
                    error_types[error_msg] += 1
                    if error_msg not in error_examples:
                        error_examples[error_msg] = error.split(':', 1)[0].strip()
            
            # Show grouped errors
            for error_msg, count in error_types.most_common(5):
                package_example = error_examples.get(error_msg, "package")
                if count == 1:
                    console.print(f"  [dim]• {package_example}: {error_msg}[/dim]")
                else:
                    console.print(f"  [dim]• {error_msg} ({count} packages, e.g., {package_example})[/dim]")
            
            if error_count > 5:
                console.print(f"  [dim]... and {error_count - len(error_types)} more errors[/dim]")
            console.print()
            
            # Provide helpful suggestions
            if any("Rate limit" in e for e in stats['errors']):
                render_info("Tip: Consider using a paid NVD API key to increase rate limits")
            if any("Connection" in e or "timeout" in e.lower() for e in stats['errors']):
                render_info("Tip: Network issues detected. Check your internet connection.")
            console.print()
    
    # Summary panel
    summary_text = (
        f"[bold]Vulnerabilities Found:[/bold] {results['vulnerabilities_found']}\n\n"
        f"[red]Critical:[/red] {summary['critical']}  "
        f"[yellow]High:[/yellow] {summary['high']}  "
        f"[cyan]Medium:[/cyan] {summary['medium']}  "
        f"[dim]Low:[/dim] {summary['low']}"
    )
    
    console.print(Panel(summary_text, title="[bold]Vulnerability Summary[/bold]", border_style="cyan"))
    console.print()
    
    if not vulns:
        render_success("No vulnerabilities found in scanned packages!")
        # Add note about scan quality
        if stats.get('api_calls_failed', 0) > 0:
            render_warning(
                f"Note: {stats.get('api_calls_failed', 0)} API call(s) failed. "
                "Some packages may not have been checked properly."
            )
        console.print()
        render_info("[dim]Note: Some distributions (Ubuntu, Debian) backport security fixes.[/dim]")
        render_info("[dim]If a package shows as vulnerable but is from a recent update, it may already be patched.[/dim]")
        return
    
    # Add note about potential false positives
    console.print()
    render_info("[yellow][dim]Note: Some distributions backport security fixes without bumping version numbers.[/dim][/yellow]")
    render_info("[dim]If a package was recently updated, verify with your distribution's security advisories.[/dim]")
    console.print()
    
    # Vulnerabilities table
    table = Table(title="[bold]Vulnerabilities[/bold]", show_header=True, header_style="bold cyan")
    table.add_column("CVE ID", style="cyan", no_wrap=True)
    table.add_column("Package", style="green")
    table.add_column("Version", style="dim")
    table.add_column("Severity", justify="center")
    table.add_column("CVSS", justify="right")
    table.add_column("Status", justify="center")
    
    # Show top 20
    for vuln in vulns[:20]:
        severity = vuln["severity"]
        severity_color = {
            "CRITICAL": "red",
            "HIGH": "yellow",
            "MEDIUM": "cyan",
            "LOW": "dim"
        }.get(severity, "white")
        
        # Check backport status
        backport_status = vuln.get("backport_status", "unknown")
        if backport_status == "patched":
            status_display = "[green]✓ PATCHED[/green]"
        elif backport_status == "vulnerable":
            status_display = "[red]VULNERABLE[/red]"
        else:
            status_display = "[yellow]? UNKNOWN[/yellow]"
        
        table.add_row(
            vuln["cve_id"],
            vuln["package"],
            vuln["package_version"],
            f"[{severity_color}]{severity}[/{severity_color}]",
            f"{vuln['cvss_score']:.1f}",
            status_display
        )
    
    console.print(table)
    console.print()
    
    if len(vulns) > 20:
        render_info(f"... and {len(vulns) - 20} more vulnerabilities. Use --execute for full report.")


def _format_scan_for_ai(scan_results: Dict[str, Any]) -> str:
    """Format scan results in a way that's useful for AI analysis."""
    if scan_results["status"] != "success":
        return f"Scan failed: {scan_results.get('message', 'Unknown error')}"
    
    summary = scan_results["summary"]
    vulns = scan_results["vulnerabilities"]
    
    output = []
    output.append("## Vulnerability Scan Results")
    output.append("")
    output.append(f"**System Information:**")
    output.append(f"- Packages Scanned: {scan_results['total_packages_scanned']}")
    output.append(f"- Vulnerabilities Found: {scan_results['vulnerabilities_found']}")
    output.append("")
    output.append("**Severity Breakdown:**")
    output.append(f"- Critical: {summary['critical']}")
    output.append(f"- High: {summary['high']}")
    output.append(f"- Medium: {summary['medium']}")
    output.append(f"- Low: {summary['low']}")
    output.append("")
    
    if vulns:
        output.append("**Vulnerabilities:**")
        output.append("")
        
        # Show all vulnerabilities (or top 50 for very large lists)
        for idx, vuln in enumerate(vulns[:50], 1):
            output.append(f"### {idx}. {vuln['cve_id']}")
            output.append(f"- **Package:** {vuln['package']} (version: {vuln['package_version']})")
            output.append(f"- **Severity:** {vuln['severity']} (CVSS: {vuln['cvss_score']:.1f})")
            output.append(f"- **Published:** {vuln['published_date']}")
            output.append(f"- **Description:** {vuln['description'][:300]}...")
            if vuln.get('references'):
                refs = vuln['references'][:3]
                output.append(f"- **References:** {', '.join(refs)}")
            output.append("")
        
        if len(vulns) > 50:
            output.append(f"... and {len(vulns) - 50} more vulnerabilities")
    
    return "\n".join(output)




def _test_cpe_query(cpe_string: str) -> None:
    """Internal test function for CPE queries (undocumented, for troubleshooting)."""
    from dav.vulnerability.nvd_client import NVDClient
    from dav.config import get_nvd_api_key
    
    console.print(Panel.fit(
        f"[bold cyan]CPE Query Test[/bold cyan]\n"
        f"[dim]CPE: {cpe_string}[/dim]",
        border_style="cyan"
    ))
    console.print()
    
    api_key = get_nvd_api_key()
    client = NVDClient(api_key=api_key)
    
    render_info(f"Querying NVD API...")
    console.print()
    
    cves, error = client.search_by_cpe(cpe_string, results_per_page=20)
    
    if error:
        render_error(f"Error: {error}")
    else:
        if cves:
            render_success(f"Found {len(cves)} CVE(s)!")
            console.print()
            
            # Show first few CVEs
            table = Table(title="CVEs Found")
            table.add_column("CVE ID", style="cyan")
            table.add_column("Published", style="dim")
            table.add_column("Description", style="white", max_width=60)
            
            for cve in cves[:10]:
                cve_id = cve.get("id", "Unknown")
                published = cve.get("published", "Unknown")
                
                # Get description
                descriptions = cve.get("descriptions", [])
                description = "No description"
                if descriptions:
                    for desc in descriptions:
                        if desc.get("lang") == "en":
                            description = desc.get("value", "No description")[:100]
                            break
                
                table.add_row(cve_id, published, description)
            
            console.print(table)
            
            if len(cves) > 10:
                console.print(f"\n[dim]... and {len(cves) - 10} more CVEs[/dim]")
        else:
            render_warning("No CVEs found for this CPE")
            console.print()
            render_info("Possible reasons:")
            console.print("  • Package has no known vulnerabilities")
            console.print("  • CPE format doesn't match NVD database")
            console.print("  • Python/pip packages are typically not in NVD")
            console.print("    (NVD focuses on system software)")


def _get_ai_remediation_suggestions(
    scan_results: Dict[str, Any],
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """Get AI-powered remediation suggestions based on scan results."""
    from dav.context import build_context, format_context_for_prompt
    from dav.ai_backend import get_system_prompt
    
    console.print()
    render_info("[bold]Getting AI security analysis and remediation suggestions...[/bold]")
    console.print()
    
    # Format scan results for AI
    scan_summary = _format_scan_for_ai(scan_results)
    
    # Build comprehensive AI prompt for security analysis
    ai_query = f"""
You are a cybersecurity expert analyzing vulnerability scan results. Provide a comprehensive security assessment and remediation plan.

Vulnerability Scan Results:
{scan_summary}

Please provide:

1. **Security Posture Summary** (2-3 sentences)
   - Overall risk assessment
   - Most critical concerns

2. **Prioritized Recommendations** (brief, actionable)
   - Focus on Critical and High severity vulnerabilities first
   - Consider system impact and update strategies

3. **Remediation Commands**
   - Provide specific, executable commands for the detected package manager
   - Include necessary steps (update package lists, upgrade packages)
   - Order commands logically (update first, then upgrade)
   - Use >>>EXEC<<< marker before each command block

4. **Additional Security Notes** (if applicable)
   - Any special considerations or warnings
   - Alternative mitigation strategies if updates aren't immediately available

IMPORTANT:
- Do NOT include any JSON structures or code blocks in your response
- Write in clear, professional language
- Be concise but informative
- Commands should be ready to execute
"""
    
    try:
        ai_backend = FailoverAIBackend()
        session_manager = SessionManager()
        
        context_data = build_context(query=ai_query, stdin_content=None)
        context_str = format_context_for_prompt(context_data)
        
        session_context = session_manager.get_conversation_context()
        if session_context:
            context_str = session_context + "\n" + context_str
        
        system_prompt = get_system_prompt(execute_mode=execute, interactive_mode=False, automation_mode=automation)
        full_prompt = context_str
        
        # Get AI response silently (don't display the raw response)
        backend_name = ai_backend.backend.title()
        
        # Show loading message
        with console.status(f"[bold cyan]Analyzing vulnerabilities with {backend_name}...", spinner="dots"):
            # Collect response without displaying it
            response = ""
            try:
                for chunk in ai_backend.stream_response(full_prompt, system_prompt=system_prompt):
                    response += chunk
            except Exception as e:
                render_error(f"Error getting AI response: {str(e)}")
                return
        
        # Clean and display the formatted AI response
        _display_ai_security_analysis(response, scan_results)
        
        # If execute mode, process any commands in response
        if execute:
            if COMMAND_EXECUTION_MARKER in response:
                execute_commands_from_response(
                    response,
                    confirm=not auto_confirm,
                    context=context_data,
                    automation_mode=automation
                )
    except Exception as e:
        render_error(f"Error getting AI suggestions: {str(e)}")
        console.print_exception()


def _display_ai_security_analysis(response: str, scan_results: Dict[str, Any]) -> None:
    """Display formatted AI security analysis and remediation suggestions."""
    import re
    from dav.executor import COMMAND_EXECUTION_MARKER, extract_commands
    from dav.terminal import strip_json_command_plan, Markdown
    
    # Clean response - remove JSON blocks and extra whitespace
    cleaned_response = strip_json_command_plan(response)
    cleaned_response = re.sub(r'\n{3,}', '\n\n', cleaned_response).strip()
    
    # Display the cleaned response using normal markdown formatting (like interactive mode)
    console.print()
    console.print(Markdown(cleaned_response))
    console.print()
    
    # Extract and check for commands
    if COMMAND_EXECUTION_MARKER in response:
        commands = extract_commands(response)
        
        if commands:
            render_info(f"Found {len(commands)} command(s) ready to execute.")
            render_info(f"Run with [cyan]dav --cve scan --execute[/cyan] to execute these commands automatically")
            console.print()
        else:
            render_warning("Command marker found but no valid commands could be extracted.")
            console.print()


