"""CLI handlers for CVE/vulnerability operations."""

from typing import Optional, Dict, Any
import requests
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn

from dav.vulnerability.scanner import VulnerabilityScanner
from dav.vulnerability.nvd_client import NVDClient
from dav.config import get_nvd_api_key
from dav.terminal import (
    render_info,
    render_warning,
    render_error,
    render_success,
    render_streaming_response_with_loading,
)
from dav.ai_backend import FailoverAIBackend
from dav.session import SessionManager
from dav.context import build_context
from dav.executor import COMMAND_EXECUTION_MARKER, execute_commands_from_response

console = Console()


def handle_cve_command(
    cve_arg: str,
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """
    Handle CVE-related commands.
    
    Args:
        cve_arg: CVE command argument (scan, scan-core, CVE-ID, or package:name)
        execute: Whether to execute remediation commands
        auto_confirm: Auto-confirm execution
        automation: Automation mode
    """
    cve_arg_lower = cve_arg.lower().strip()
    
    # Internal test mode (undocumented, for troubleshooting)
    if cve_arg_lower.startswith("test:"):
        test_cpe = cve_arg[5:].strip()
        _test_cpe_query(test_cpe)
        return
    
    if cve_arg_lower == "scan" or cve_arg_lower == "":
        handle_system_scan(execute=execute, auto_confirm=auto_confirm, automation=automation)
    elif cve_arg_lower == "scan-core":
        handle_system_scan(core_only=True, execute=execute, auto_confirm=auto_confirm, automation=automation)
    else:
        # Treat any other input as a query for AI analysis after scan
        handle_system_scan_with_query(
            cve_arg,
            execute=execute,
            auto_confirm=auto_confirm,
            automation=automation
        )


def handle_system_scan(
    core_only: bool = False,
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """Handle system-wide vulnerability scan."""
    api_key = get_nvd_api_key()
    scanner = VulnerabilityScanner(nvd_api_key=api_key)
    
    # Show initial info
    scan_type = "Core Security Packages" if core_only else "System Packages"
    console.print(Panel.fit(
        f"[bold cyan]Vulnerability Scanner[/bold cyan]\n"
        f"[dim]Scanning {scan_type.lower()} against NVD database[/dim]",
        border_style="cyan"
    ))
    console.print()
    
    if core_only:
        render_info("Scanning only core security-critical packages (OpenSSL, SSH, system libraries, etc.)")
        console.print()
    
    # Show rate limit info
    rate_info = scanner.nvd_client.get_rate_limit_info()
    tier_text = "paid tier" if rate_info["tier"] == "paid" else "free tier"
    render_info(
        f"Using NVD API {tier_text} "
        f"({rate_info['limit']} requests per {rate_info['window_seconds']} seconds)"
    )
    console.print()
    
    # Perform scan with progress
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
        TextColumn("({task.completed}/{task.total})"),
        TimeElapsedColumn(),
        console=console
    ) as progress:
        task = progress.add_task("Scanning packages...", total=100)
        
        def progress_callback(current: int, total: int, package_name: str):
            percentage = int((current / total) * 100) if total > 0 else 0
            progress.update(
                task,
                completed=percentage,
                total=100,
                description=f"Scanning {package_name[:30]}... ({current}/{total} packages)"
            )
        
        results = scanner.scan_system(progress_callback=progress_callback, core_only=core_only)
    
    # Display results
    _display_scan_results(results, execute=execute, auto_confirm=auto_confirm)
    
    # If vulnerabilities found, get AI suggestions for remediation
    if results.get("status") == "success" and results.get("vulnerabilities_found", 0) > 0:
        _get_ai_remediation_suggestions(results, execute=execute, auto_confirm=auto_confirm, automation=automation)
    
    # Show cache info only if there's an issue
    cache_size = scanner.cache.get_cache_size()
    if cache_size == 0:
        cache_dir = scanner.cache.cache_dir
        render_warning(f"Cache: No entries found in {cache_dir} (check write permissions)")


def handle_system_scan_with_query(
    query: str,
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """Handle system scan with AI analysis of results."""
    # Perform scan first
    api_key = get_nvd_api_key()
    scanner = VulnerabilityScanner(nvd_api_key=api_key)
    
    console.print(Panel.fit(
        "[bold cyan]Vulnerability Scan with AI Analysis[/bold cyan]\n"
        "[dim]Scanning system and analyzing results[/dim]",
        border_style="cyan"
    ))
    
    render_info(f"Query: {query}")
    console.print()
    
    # Show rate limit info
    rate_info = scanner.nvd_client.get_rate_limit_info()
    tier_text = "paid tier" if rate_info["tier"] == "paid" else "free tier"
    render_info(
        f"Using NVD API {tier_text} "
        f"({rate_info['limit']} requests per {rate_info['window_seconds']} seconds)"
    )
    render_warning("Scanning may take several minutes due to API rate limits.")
    console.print()
    
    # Perform scan with progress
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
        TextColumn("({task.completed}/{task.total})"),
        TimeElapsedColumn(),
        console=console
    ) as progress:
        task = progress.add_task("Scanning packages...", total=100)
        
        def progress_callback(current: int, total: int, package_name: str):
            percentage = int((current / total) * 100) if total > 0 else 0
            progress.update(
                task,
                completed=percentage,
                total=100,
                description=f"Scanning {package_name[:30]}... ({current}/{total} packages)"
            )
        
        scan_results = scanner.scan_system(progress_callback=progress_callback)
    
    # Format results for AI
    scan_summary = _format_scan_for_ai(scan_results)
    
    # Send to AI for analysis
    render_info("\n[bold]Analyzing scan results with AI...[/bold]\n")
    
    # Build AI prompt
    ai_query = f"""
{query}

Here are the vulnerability scan results from my system:

{scan_summary}

Please analyze these results and provide:
1. A summary of the security posture
2. Prioritized recommendations
3. Specific actions I should take
"""
    
    # Initialize AI backend
    try:
        ai_backend = FailoverAIBackend()
        session_manager = SessionManager()
        
        # Build prompt with context (duplicate logic from cli.py to avoid circular import)
        from dav.context import build_context, format_context_for_prompt
        from dav.ai_backend import get_system_prompt
        
        context_data = build_context(query=ai_query, stdin_content=None)
        context_str = format_context_for_prompt(context_data)
        
        session_context = session_manager.get_conversation_context()
        if session_context:
            context_str = session_context + "\n" + context_str
        
        system_prompt = get_system_prompt(execute_mode=execute, interactive_mode=False, automation_mode=automation)
        full_prompt = context_str
        
        # Get AI response
        backend_name = ai_backend.backend.title()
        response = render_streaming_response_with_loading(
            ai_backend.stream_response(full_prompt, system_prompt=system_prompt),
            loading_message=f"Analyzing vulnerabilities with {backend_name}...",
        )
        
        # Display AI response
        console.print("\n" + response + "\n")
        
        # If execute mode, process any commands in response
        if execute:
            if COMMAND_EXECUTION_MARKER in response:
                execute_commands_from_response(
                    response,
                    confirm=not auto_confirm,
                    context=context_data,
                    automation_mode=automation
                )
    except Exception as e:
        render_error(f"Error during AI analysis: {str(e)}")
        console.print_exception()
        # Still show scan results even if AI analysis failed
        _display_scan_results(scan_results, execute=execute, auto_confirm=auto_confirm)
    
    # Show cache info only if there's an issue
    cache_size = scanner.cache.get_cache_size()
    if cache_size == 0:
        cache_dir = scanner.cache.cache_dir
        render_warning(f"Cache: No entries found in {cache_dir} (check write permissions)")


def _display_scan_results(
    results: Dict[str, Any],
    execute: bool = False,
    auto_confirm: bool = False
) -> None:
    """Display scan results in a formatted table."""
    if results["status"] != "success":
        render_error(f"Scan failed: {results.get('message', 'Unknown error')}")
        return
    
    summary = results["summary"]
    vulns = results["vulnerabilities"]
    stats = results.get("statistics", {})
    
    # Statistics panel
    stats_text = (
        f"[bold]Packages Processed:[/bold] {results['total_packages_scanned']}\n"
    )
    
    if stats:
        stats_text += f"[bold]API Calls:[/bold] {stats.get('api_calls_made', 0)} made, "
        stats_text += f"[green]{stats.get('api_calls_succeeded', 0)} succeeded[/green], "
        stats_text += f"[red]{stats.get('api_calls_failed', 0)} failed[/red]\n"
        stats_text += f"[bold]Cache:[/bold] [green]{stats.get('cache_hits', 0)} hits[/green], "
        stats_text += f"[yellow]{stats.get('cache_misses', 0)} misses[/yellow]\n"
        if stats.get('packages_skipped', 0) > 0:
            stats_text += f"[bold]Skipped:[/bold] {stats.get('packages_skipped', 0)} packages (no CPE mapping)\n"
    
    console.print(Panel(stats_text, title="[bold]Scan Statistics[/bold]", border_style="blue"))
    console.print()
    
    # Show errors if any
    if stats.get('errors'):
        error_count = len(stats['errors'])
        if error_count > 0:
            render_warning(f"Encountered {error_count} API error(s) during scan:")
            console.print()
            
            # Group errors by type for better readability
            from collections import Counter
            error_types = Counter()
            error_examples = {}
            
            for error in stats['errors']:
                # Extract error type (last part after colon)
                if ':' in error:
                    error_msg = error.split(':', 1)[1].strip()
                    error_types[error_msg] += 1
                    if error_msg not in error_examples:
                        error_examples[error_msg] = error.split(':', 1)[0].strip()
            
            # Show grouped errors
            for error_msg, count in error_types.most_common(5):
                package_example = error_examples.get(error_msg, "package")
                if count == 1:
                    console.print(f"  [dim]â€¢ {package_example}: {error_msg}[/dim]")
                else:
                    console.print(f"  [dim]â€¢ {error_msg} ({count} packages, e.g., {package_example})[/dim]")
            
            if error_count > 5:
                console.print(f"  [dim]... and {error_count - len(error_types)} more errors[/dim]")
            console.print()
            
            # Provide helpful suggestions
            if any("Rate limit" in e for e in stats['errors']):
                render_info("Tip: Consider using a paid NVD API key to increase rate limits")
            if any("Connection" in e or "timeout" in e.lower() for e in stats['errors']):
                render_info("Tip: Network issues detected. Check your internet connection.")
            console.print()
    
    # Summary panel
    summary_text = (
        f"[bold]Vulnerabilities Found:[/bold] {results['vulnerabilities_found']}\n\n"
        f"[red]Critical:[/red] {summary['critical']}  "
        f"[yellow]High:[/yellow] {summary['high']}  "
        f"[cyan]Medium:[/cyan] {summary['medium']}  "
        f"[dim]Low:[/dim] {summary['low']}"
    )
    
    console.print(Panel(summary_text, title="[bold]Vulnerability Summary[/bold]", border_style="cyan"))
    console.print()
    
    if not vulns:
        render_success("No vulnerabilities found in scanned packages!")
        # Add note about scan quality
        if stats.get('api_calls_failed', 0) > 0:
            render_warning(
                f"Note: {stats.get('api_calls_failed', 0)} API call(s) failed. "
                "Some packages may not have been checked properly."
            )
        console.print()
        render_info("[dim]Note: Some distributions (Ubuntu, Debian) backport security fixes.[/dim]")
        render_info("[dim]If a package shows as vulnerable but is from a recent update, it may already be patched.[/dim]")
        return
    
    # Add note about potential false positives
    console.print()
    render_info("[yellow][dim]Note: Some distributions backport security fixes without bumping version numbers.[/dim][/yellow]")
    render_info("[dim]If a package was recently updated, verify with your distribution's security advisories.[/dim]")
    console.print()
    
    # Vulnerabilities table
    table = Table(title="[bold]Vulnerabilities[/bold]", show_header=True, header_style="bold cyan")
    table.add_column("CVE ID", style="cyan", no_wrap=True)
    table.add_column("Package", style="green")
    table.add_column("Version", style="dim")
    table.add_column("Severity", justify="center")
    table.add_column("CVSS", justify="right")
    
    # Show top 20
    for vuln in vulns[:20]:
        severity = vuln["severity"]
        severity_color = {
            "CRITICAL": "red",
            "HIGH": "yellow",
            "MEDIUM": "cyan",
            "LOW": "dim"
        }.get(severity, "white")
        
        table.add_row(
            vuln["cve_id"],
            vuln["package"],
            vuln["package_version"],
            f"[{severity_color}]{severity}[/{severity_color}]",
            f"{vuln['cvss_score']:.1f}"
        )
    
    console.print(table)
    console.print()
    
    if len(vulns) > 20:
        render_info(f"... and {len(vulns) - 20} more vulnerabilities. Use --execute for full report.")
    
    # Show remediation if execute mode
    if execute:
        _suggest_remediation(vulns, auto_confirm=auto_confirm)


def _format_scan_for_ai(scan_results: Dict[str, Any]) -> str:
    """Format scan results in a way that's useful for AI analysis."""
    if scan_results["status"] != "success":
        return f"Scan failed: {scan_results.get('message', 'Unknown error')}"
    
    summary = scan_results["summary"]
    vulns = scan_results["vulnerabilities"]
    
    output = []
    output.append("## Vulnerability Scan Results")
    output.append("")
    output.append(f"**System Information:**")
    output.append(f"- Packages Scanned: {scan_results['total_packages_scanned']}")
    output.append(f"- Vulnerabilities Found: {scan_results['vulnerabilities_found']}")
    output.append("")
    output.append("**Severity Breakdown:**")
    output.append(f"- Critical: {summary['critical']}")
    output.append(f"- High: {summary['high']}")
    output.append(f"- Medium: {summary['medium']}")
    output.append(f"- Low: {summary['low']}")
    output.append("")
    
    if vulns:
        output.append("**Vulnerabilities:**")
        output.append("")
        
        # Show all vulnerabilities (or top 50 for very large lists)
        for idx, vuln in enumerate(vulns[:50], 1):
            output.append(f"### {idx}. {vuln['cve_id']}")
            output.append(f"- **Package:** {vuln['package']} (version: {vuln['package_version']})")
            output.append(f"- **Severity:** {vuln['severity']} (CVSS: {vuln['cvss_score']:.1f})")
            output.append(f"- **Published:** {vuln['published_date']}")
            output.append(f"- **Description:** {vuln['description'][:300]}...")
            if vuln.get('references'):
                refs = vuln['references'][:3]
                output.append(f"- **References:** {', '.join(refs)}")
            output.append("")
        
        if len(vulns) > 50:
            output.append(f"... and {len(vulns) - 50} more vulnerabilities")
    
    return "\n".join(output)


def _suggest_remediation(vulnerabilities: list, auto_confirm: bool = False) -> None:
    """Suggest remediation steps for vulnerabilities."""
    if not vulnerabilities:
        return
    
    render_info("\n[bold]Remediation Suggestions:[/bold]")
    
    # Group by package
    by_package = {}
    for vuln in vulnerabilities:
        pkg = vuln["package"]
        if pkg not in by_package:
            by_package[pkg] = []
        by_package[pkg].append(vuln)
    
    # Show upgrade commands
    console.print("\n[bold]Recommended Actions:[/bold]\n")
    
    for package, vulns in list(by_package.items())[:10]:  # Top 10 packages
        highest_severity = max(vulns, key=lambda x: x.get("cvss_score", 0))
        
        console.print(f"[cyan]{package}[/cyan] - {len(vulns)} vulnerability/vulnerabilities")
        console.print(f"  Highest severity: {highest_severity['severity']} (CVSS: {highest_severity['cvss_score']:.1f})")
        console.print(f"  [dim]Recommendation: Check for available updates[/dim]\n")


def _test_cpe_query(cpe_string: str) -> None:
    """Internal test function for CPE queries (undocumented, for troubleshooting)."""
    from dav.vulnerability.nvd_client import NVDClient
    from dav.config import get_nvd_api_key
    
    console.print(Panel.fit(
        f"[bold cyan]CPE Query Test[/bold cyan]\n"
        f"[dim]CPE: {cpe_string}[/dim]",
        border_style="cyan"
    ))
    console.print()
    
    api_key = get_nvd_api_key()
    client = NVDClient(api_key=api_key)
    
    render_info(f"Querying NVD API...")
    console.print()
    
    cves, error = client.search_by_cpe(cpe_string, results_per_page=20)
    
    if error:
        render_error(f"Error: {error}")
    else:
        if cves:
            render_success(f"Found {len(cves)} CVE(s)!")
            console.print()
            
            # Show first few CVEs
            table = Table(title="CVEs Found")
            table.add_column("CVE ID", style="cyan")
            table.add_column("Published", style="dim")
            table.add_column("Description", style="white", max_width=60)
            
            for cve in cves[:10]:
                cve_id = cve.get("id", "Unknown")
                published = cve.get("published", "Unknown")
                
                # Get description
                descriptions = cve.get("descriptions", [])
                description = "No description"
                if descriptions:
                    for desc in descriptions:
                        if desc.get("lang") == "en":
                            description = desc.get("value", "No description")[:100]
                            break
                
                table.add_row(cve_id, published, description)
            
            console.print(table)
            
            if len(cves) > 10:
                console.print(f"\n[dim]... and {len(cves) - 10} more CVEs[/dim]")
        else:
            render_warning("No CVEs found for this CPE")
            console.print()
            render_info("Possible reasons:")
            console.print("  â€¢ Package has no known vulnerabilities")
            console.print("  â€¢ CPE format doesn't match NVD database")
            console.print("  â€¢ Python/pip packages are typically not in NVD")
            console.print("    (NVD focuses on system software)")


def _get_ai_remediation_suggestions(
    scan_results: Dict[str, Any],
    execute: bool = False,
    auto_confirm: bool = False,
    automation: bool = False
) -> None:
    """Get AI-powered remediation suggestions based on scan results."""
    from dav.context import build_context, format_context_for_prompt
    from dav.ai_backend import get_system_prompt
    
    console.print()
    render_info("[bold]Getting AI security analysis and remediation suggestions...[/bold]")
    console.print()
    
    # Format scan results for AI
    scan_summary = _format_scan_for_ai(scan_results)
    
    # Build comprehensive AI prompt for security analysis
    ai_query = f"""
You are a cybersecurity expert analyzing vulnerability scan results. Provide a comprehensive security assessment and remediation plan.

Vulnerability Scan Results:
{scan_summary}

Please provide:

1. **Security Posture Summary** (2-3 sentences)
   - Overall risk assessment
   - Most critical concerns

2. **Prioritized Recommendations** (brief, actionable)
   - Focus on Critical and High severity vulnerabilities first
   - Consider system impact and update strategies

3. **Remediation Commands**
   - Provide specific, executable commands for the detected package manager
   - Include necessary steps (update package lists, upgrade packages)
   - Order commands logically (update first, then upgrade)
   - Use >>>EXEC<<< marker before each command block

4. **Additional Security Notes** (if applicable)
   - Any special considerations or warnings
   - Alternative mitigation strategies if updates aren't immediately available

IMPORTANT:
- Do NOT include any JSON structures or code blocks in your response
- Write in clear, professional language
- Be concise but informative
- Commands should be ready to execute
"""
    
    try:
        ai_backend = FailoverAIBackend()
        session_manager = SessionManager()
        
        context_data = build_context(query=ai_query, stdin_content=None)
        context_str = format_context_for_prompt(context_data)
        
        session_context = session_manager.get_conversation_context()
        if session_context:
            context_str = session_context + "\n" + context_str
        
        system_prompt = get_system_prompt(execute_mode=execute, interactive_mode=False, automation_mode=automation)
        full_prompt = context_str
        
        # Get AI response silently (don't display the raw response)
        backend_name = ai_backend.backend.title()
        
        # Show loading message
        with console.status(f"[bold cyan]Analyzing vulnerabilities with {backend_name}...", spinner="dots"):
            # Collect response without displaying it
            response = ""
            try:
                for chunk in ai_backend.stream_response(full_prompt, system_prompt=system_prompt):
                    response += chunk
            except Exception as e:
                render_error(f"Error getting AI response: {str(e)}")
                return
        
        # Clean and display the formatted AI response
        _display_ai_security_analysis(response, scan_results)
        
        # If execute mode, process any commands in response
        if execute:
            if COMMAND_EXECUTION_MARKER in response:
                execute_commands_from_response(
                    response,
                    confirm=not auto_confirm,
                    context=context_data,
                    automation_mode=automation
                )
    except Exception as e:
        render_error(f"Error getting AI suggestions: {str(e)}")
        console.print_exception()


def _display_ai_security_analysis(response: str, scan_results: Dict[str, Any]) -> None:
    """Display formatted AI security analysis and remediation suggestions."""
    from dav.executor import COMMAND_EXECUTION_MARKER, extract_commands
    from dav.terminal import strip_json_command_plan
    import re
    
    # Clean response - remove JSON blocks and extra whitespace
    cleaned_response = strip_json_command_plan(response)
    cleaned_response = re.sub(r'\n{3,}', '\n\n', cleaned_response).strip()
    
    # Split response into sections
    sections = _parse_ai_response_sections(cleaned_response)
    
    # Display Security Posture Summary
    if sections.get('summary'):
        summary_text = sections['summary'].strip()
        console.print(Panel(
            summary_text,
            title="[bold cyan]ðŸ”’ Security Posture Summary[/bold cyan]",
            border_style="cyan",
            padding=(1, 2)
        ))
        console.print()
    
    # Display Recommendations
    if sections.get('recommendations'):
        rec_text = sections['recommendations'].strip()
        console.print(Panel(
            rec_text,
            title="[bold yellow]ðŸ’¡ Prioritized Recommendations[/bold yellow]",
            border_style="yellow",
            padding=(1, 2)
        ))
        console.print()
    
    # Extract and display commands
    if COMMAND_EXECUTION_MARKER in response:
        commands = extract_commands(response)
        
        if commands:
            # Format commands nicely
            cmd_text = "\n".join([f"{idx}. {cmd.strip()}" for idx, cmd in enumerate(commands, 1)])
            
            console.print(Panel(
                cmd_text,
                title="[bold green]âš¡ Remediation Commands[/bold green]",
                border_style="green",
                padding=(1, 2)
            ))
            console.print()
            
            # Show execution hint
            render_info(f"ðŸ’» Run with [cyan]dav --cve scan --execute[/cyan] to execute these commands automatically")
            console.print()
        else:
            render_warning("âš ï¸  No executable commands found in AI response")
            console.print()
    else:
        # Check if there are commands mentioned in text but without marker
        if any(keyword in cleaned_response.lower() for keyword in ['sudo apt', 'yum update', 'dnf update', 'apt-get']):
            render_warning("âš ï¸  Commands detected but not properly formatted. Review the recommendations above.")
            console.print()
    
    # Display Additional Notes
    if sections.get('notes'):
        notes_text = sections['notes'].strip()
        console.print(Panel(
            notes_text,
            title="[bold blue]ðŸ“‹ Additional Security Notes[/bold blue]",
            border_style="blue",
            padding=(1, 2)
        ))
        console.print()
    
    # If no structured sections, display the cleaned response as-is
    if not any(sections.values()) and cleaned_response:
        # Try to display the full response in a readable format
        console.print(Panel(
            cleaned_response,
            title="[bold]AI Security Analysis[/bold]",
            border_style="cyan",
            padding=(1, 2)
        ))
        console.print()


def _parse_ai_response_sections(response: str) -> Dict[str, str]:
    """Parse AI response into structured sections."""
    sections = {
        'summary': '',
        'recommendations': '',
        'commands': '',
        'notes': ''
    }
    
    # Split by common section markers
    import re
    
    # Look for numbered sections or headers
    section_patterns = {
        'summary': re.compile(r'(?:^|\n)\s*(?:1\.|#+\s*)?(?:Security\s+Posture|Summary|Overall|Assessment)[:.]?\s*\n', re.IGNORECASE),
        'recommendations': re.compile(r'(?:^|\n)\s*(?:2\.|#+\s*)?(?:Recommendation|Prioritized|Action|Steps)[:.]?\s*\n', re.IGNORECASE),
        'commands': re.compile(r'(?:^|\n)\s*(?:3\.|#+\s*)?(?:Remediation\s+Command|Command|Update|Upgrade)[:.]?\s*\n', re.IGNORECASE),
        'notes': re.compile(r'(?:^|\n)\s*(?:4\.|#+\s*)?(?:Note|Consideration|Warning|Additional|Alternative)[:.]?\s*\n', re.IGNORECASE),
    }
    
    # Try to split by patterns
    parts = []
    last_pos = 0
    
    # Find all section markers
    markers = []
    for section_name, pattern in section_patterns.items():
        for match in pattern.finditer(response):
            markers.append((match.start(), section_name))
    
    # Sort by position
    markers.sort(key=lambda x: x[0])
    
    if markers:
        # Extract sections based on markers
        for i, (pos, section_name) in enumerate(markers):
            # Get content from this marker to next marker (or end)
            next_pos = markers[i + 1][0] if i + 1 < len(markers) else len(response)
            content = response[pos:next_pos]
            
            # Remove the header line
            content = re.sub(r'^.*?\n', '', content, count=1)
            
            if content.strip():
                sections[section_name] = content.strip()
    else:
        # No clear sections found - try line-by-line parsing
        lines = response.split('\n')
        current_section = None
        current_content = []
        
        for line in lines:
            line_stripped = line.strip()
            line_lower = line_stripped.lower()
            
            # Skip empty lines at section boundaries
            if not line_stripped:
                if current_content:
                    current_content.append('')
                continue
            
            # Detect section headers (more flexible)
            if re.match(r'^[#*]*\s*(?:1\.|Security\s+Posture|Summary|Overall)', line_lower):
                if current_section:
                    sections[current_section] = '\n'.join(current_content).strip()
                current_section = 'summary'
                current_content = []
                continue
            elif re.match(r'^[#*]*\s*(?:2\.|Recommendation|Prioritized|Action|Steps)', line_lower):
                if current_section:
                    sections[current_section] = '\n'.join(current_content).strip()
                current_section = 'recommendations'
                current_content = []
                continue
            elif re.match(r'^[#*]*\s*(?:3\.|Remediation|Command|Update|Upgrade)', line_lower) and '>>>EXEC<<<' not in line:
                if current_section:
                    sections[current_section] = '\n'.join(current_content).strip()
                current_section = 'commands'
                current_content = []
                continue
            elif re.match(r'^[#*]*\s*(?:4\.|Note|Consideration|Warning|Additional|Alternative)', line_lower):
                if current_section:
                    sections[current_section] = '\n'.join(current_content).strip()
                current_section = 'notes'
                current_content = []
                continue
            
            # Add content to current section
            if current_section:
                # Skip markdown formatting but keep content
                if not (line_stripped.startswith('#') and len(line_stripped.split()) <= 3):
                    current_content.append(line)
            else:
                # Content before any section - add to summary
                if not (line_stripped.startswith('#') and len(line_stripped.split()) <= 3):
                    current_content.append(line)
        
        # Save last section
        if current_section:
            sections[current_section] = '\n'.join(current_content).strip()
        elif current_content:
            # No section detected, put everything in summary
            sections['summary'] = '\n'.join(current_content).strip()
    
    # If still no sections found, put everything in summary
    if not any(sections.values()):
        sections['summary'] = response.strip()
    
    return sections
