"""NVD API client with rate limiting support."""

import time
from collections import deque
from typing import Optional, Dict, List, Tuple

import requests

from dav.config import get_nvd_api_key


class NVDClient:
    """NVD API client with automatic rate limiting."""
    
    # Rate limits
    FREE_TIER_LIMIT = 50  # requests per 30 seconds
    PAID_TIER_LIMIT = 200  # requests per 30 seconds
    RATE_WINDOW = 30  # seconds
    
    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize NVD API client.
        
        Args:
            api_key: Optional NVD API key. If provided, uses paid tier (200 req/30s).
                     If None, uses free tier (50 req/30s).
        """
        self.api_key = api_key or get_nvd_api_key()
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        
        # Determine rate limits based on API key presence
        if self.api_key:
            self.rate_limit = self.PAID_TIER_LIMIT
            self.min_request_interval = self.RATE_WINDOW / self.PAID_TIER_LIMIT  # ~0.15s
        else:
            self.rate_limit = self.FREE_TIER_LIMIT
            self.min_request_interval = self.RATE_WINDOW / self.FREE_TIER_LIMIT  # ~0.6s
        
        # Track request timestamps for rate limiting
        self.request_times: deque = deque()
    
    def _wait_for_rate_limit(self) -> None:
        """
        Wait if we're approaching rate limit.
        
        Implements sliding window rate limiting by tracking request timestamps
        and waiting when necessary.
        """
        now = time.time()
        
        # Remove requests older than rate window
        while self.request_times and (now - self.request_times[0]) > self.RATE_WINDOW:
            self.request_times.popleft()
        
        # If we're at the limit, wait until oldest request expires
        if len(self.request_times) >= self.rate_limit:
            oldest_request_time = self.request_times[0]
            sleep_time = self.RATE_WINDOW - (now - oldest_request_time) + 0.1
            if sleep_time > 0:
                time.sleep(sleep_time)
                # Clean up old requests after waiting
                now = time.time()
                while self.request_times and (now - self.request_times[0]) > self.RATE_WINDOW:
                    self.request_times.popleft()
        
        # Record this request
        self.request_times.append(time.time())
        
        # Always wait minimum interval to be safe
        time.sleep(self.min_request_interval)
    
    def lookup_cve(self, cve_id: str) -> Optional[Dict]:
        """
        Lookup a specific CVE by ID.
        
        Args:
            cve_id: CVE ID (e.g., "CVE-2024-12345")
        
        Returns:
            CVE data dictionary or None if not found/error
        """
        self._wait_for_rate_limit()
        
        headers = {}
        if self.api_key:
            headers["apiKey"] = self.api_key
        
        params = {"cveId": cve_id}
        
        try:
            response = requests.get(
                self.base_url,
                params=params,
                headers=headers,
                timeout=10
            )
            response.raise_for_status()
            data = response.json()
            
            if data.get("vulnerabilities"):
                return data["vulnerabilities"][0]["cve"]
            return None
        except requests.exceptions.RequestException:
            return None
        except (KeyError, IndexError, ValueError):
            return None
    
    def search_by_cpe(self, cpe_string: str, results_per_page: int = 20) -> Tuple[List[Dict], Optional[str]]:
        """
        Search CVEs by CPE string.
        
        Args:
            cpe_string: CPE 2.3 format string
            results_per_page: Maximum number of results to return
        
        Returns:
            Tuple of (list of CVE dictionaries, error_message)
            If successful, error_message is None
        """
        self._wait_for_rate_limit()
        
        headers = {}
        if self.api_key:
            headers["apiKey"] = self.api_key
        
        params = {
            "virtualMatchString": cpe_string,
            "resultsPerPage": results_per_page
        }
        
        try:
            response = requests.get(
                self.base_url,
                params=params,
                headers=headers,
                timeout=10
            )
            response.raise_for_status()
            data = response.json()
            
            cves = []
            if data.get("vulnerabilities"):
                for vuln in data["vulnerabilities"]:
                    cves.append(vuln["cve"])
            
            return cves, None
        except requests.exceptions.Timeout:
            return [], "Request timeout"
        except requests.exceptions.ConnectionError:
            return [], "Connection error"
        except requests.exceptions.HTTPError as e:
            error_detail = ""
            try:
                if e.response.content:
                    error_detail = f" - {e.response.text[:100]}"
            except:
                pass
            
            if e.response.status_code == 429:
                return [], f"Rate limit exceeded{error_detail}"
            elif e.response.status_code == 403:
                return [], f"Forbidden (check API key){error_detail}"
            elif e.response.status_code == 400:
                return [], f"Bad request (invalid CPE format?){error_detail}"
            elif e.response.status_code >= 500:
                return [], f"Server error ({e.response.status_code}){error_detail}"
            else:
                return [], f"HTTP error ({e.response.status_code}){error_detail}"
        except requests.exceptions.RequestException as e:
            return [], f"Request error: {str(e)}"
        except (KeyError, ValueError) as e:
            return [], f"Parse error: {str(e)}"
    
    def get_rate_limit_info(self) -> Dict[str, any]:
        """
        Get current rate limit information.
        
        Returns:
            Dictionary with rate limit details
        """
        now = time.time()
        # Clean up old requests
        while self.request_times and (now - self.request_times[0]) > self.RATE_WINDOW:
            self.request_times.popleft()
        
        return {
            "tier": "paid" if self.api_key else "free",
            "limit": self.rate_limit,
            "window_seconds": self.RATE_WINDOW,
            "current_requests": len(self.request_times),
            "remaining_requests": max(0, self.rate_limit - len(self.request_times)),
            "min_interval_seconds": self.min_request_interval
        }
