"""Package inventory collection from various package managers."""

import json
import subprocess
from pathlib import Path
from typing import Dict, List, Any

from dav.context import get_os_info


class PackageInventory:
    """Collect installed packages from the system."""
    
    # Core security-critical packages that should be scanned
    CORE_PACKAGE_PATTERNS = {
        # Security & Crypto
        "openssl", "libssl", "ssl", "libcrypto", "gnutls", "libgnutls",
        # System Libraries
        "glibc", "libc6", "libc-", "libc.so", "libc++",
        # Authentication & Access
        "sudo", "ssh", "openssh", "pam", "libpam",
        # Network Services
        "nginx", "apache2", "httpd", "apache",
        # Database Servers
        "postgresql", "mysql", "mariadb", "redis",
        # Kernel
        "linux-image", "kernel", "linux-headers",
        # System Utilities
        "curl", "wget", "git",
        # Compression
        "zlib", "libz",
        # Web Servers & Proxies
        "haproxy", "squid",
        # DNS
        "bind9", "dnsmasq",
        # Mail
        "postfix", "sendmail", "exim",
        # Monitoring
        "rsyslog", "syslog",
    }
    
    def __init__(self):
        """Initialize package inventory collector."""
        self.os_info = get_os_info()
    
    def collect_all_packages(self) -> Dict[str, Any]:
        """
        Collect all packages from all available managers.
        
        Returns:
            Dictionary with package lists by source:
            {
                "system_packages": [...],
                "python_packages": [...],
                "os_info": {...}
            }
        """
        inventory = {
            "system_packages": [],
            "python_packages": [],
            "os_info": self.os_info
        }
        
        # System packages based on OS
        if self.os_info.get("system") == "Linux":
            distro_id = self.os_info.get("distribution_id", "").lower()
            
            if distro_id in ["ubuntu", "debian"]:
                inventory["system_packages"] = self._collect_dpkg()
            elif distro_id in ["fedora", "rhel", "centos", "rocky", "almalinux"]:
                inventory["system_packages"] = self._collect_rpm()
        
        # Language packages
        inventory["python_packages"] = self._collect_python()
        
        return inventory
    
    def collect_core_packages(self) -> Dict[str, Any]:
        """
        Collect only core security-critical packages.
        
        Returns:
            Dictionary with filtered package lists containing only core packages
        """
        inventory = self.collect_all_packages()
        
        # Filter system packages to only core ones
        core_system_packages = self._filter_core_packages(inventory.get("system_packages", []))
        
        # Don't include Python packages in core scan (they're not in NVD anyway)
        
        return {
            "system_packages": core_system_packages,
            "python_packages": [],
            "os_info": inventory["os_info"]
        }
    
    def _filter_core_packages(self, packages: List[Dict[str, str]]) -> List[Dict[str, str]]:
        """
        Filter packages to only include core security-critical ones.
        
        Args:
            packages: List of package dictionaries
        
        Returns:
            Filtered list of core packages
        """
        core_packages = []
        package_names_lower = {pkg["name"].lower() for pkg in packages}
        
        for package in packages:
            package_name_lower = package["name"].lower()
            
            # Check if package name matches any core pattern
            is_core = False
            for pattern in self.CORE_PACKAGE_PATTERNS:
                if pattern in package_name_lower:
                    is_core = True
                    break
            
            # Also check for common security package prefixes/suffixes
            if not is_core:
                # Check for lib- packages that might be security-critical
                if package_name_lower.startswith("lib") and any(
                    sec_term in package_name_lower 
                    for sec_term in ["ssl", "crypto", "tls", "pam", "c-", "z"]
                ):
                    is_core = True
            
            if is_core:
                core_packages.append(package)
        
        return core_packages
    
    def _collect_dpkg(self) -> List[Dict[str, str]]:
        """
        Collect Debian/Ubuntu packages using dpkg.
        
        Returns:
            List of package dictionaries
        """
        try:
            result = subprocess.run(
                ["dpkg-query", "-W", "-f=${Package}|${Version}|${Architecture}\n"],
                capture_output=True,
                text=True,
                timeout=30,
                check=False
            )
            
            if result.returncode != 0:
                return []
            
            packages = []
            for line in result.stdout.strip().split('\n'):
                if '|' in line:
                    parts = line.split('|')
                    if len(parts) >= 2:
                        packages.append({
                            "name": parts[0],
                            "version": parts[1],
                            "architecture": parts[2] if len(parts) > 2 else "unknown",
                            "manager": "dpkg",
                            "source": "system"
                        })
            return packages
        except (subprocess.TimeoutExpired, FileNotFoundError, Exception):
            return []
    
    def _collect_rpm(self) -> List[Dict[str, str]]:
        """
        Collect RPM packages using rpm.
        
        Returns:
            List of package dictionaries
        """
        try:
            result = subprocess.run(
                ["rpm", "-qa", "--queryformat", "%{NAME}|%{VERSION}|%{ARCH}\n"],
                capture_output=True,
                text=True,
                timeout=30,
                check=False
            )
            
            if result.returncode != 0:
                return []
            
            packages = []
            for line in result.stdout.strip().split('\n'):
                if '|' in line:
                    parts = line.split('|')
                    if len(parts) >= 2:
                        packages.append({
                            "name": parts[0],
                            "version": parts[1],
                            "architecture": parts[2] if len(parts) > 2 else "unknown",
                            "manager": "rpm",
                            "source": "system"
                        })
            return packages
        except (subprocess.TimeoutExpired, FileNotFoundError, Exception):
            return []
    
    def _collect_python(self) -> List[Dict[str, str]]:
        """
        Collect Python packages using pip.
        
        Returns:
            List of package dictionaries
        """
        try:
            result = subprocess.run(
                ["pip", "list", "--format", "json"],
                capture_output=True,
                text=True,
                timeout=30,
                check=False
            )
            
            if result.returncode != 0:
                return []
            
            packages_data = json.loads(result.stdout)
            return [{
                "name": p["name"],
                "version": p["version"],
                "manager": "pip",
                "source": "python"
            } for p in packages_data]
        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError, Exception):
            return []
