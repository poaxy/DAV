"""Distribution security advisory checking for backport detection."""

import time
from typing import Dict, List, Optional, Tuple, Any
import requests

from dav.vulnerability.cache import CVECache


class DistributionSecurityChecker:
    """Check distribution security advisories to detect backported fixes."""
    
    def __init__(self, os_info: Dict[str, Any], cache: Optional[CVECache] = None):
        """
        Initialize distribution security checker.
        
        Args:
            os_info: OS information dictionary
            cache: Optional CVE cache instance to reuse
        """
        self.os_info = os_info
        self.distro_id = os_info.get("distribution_id", "").lower()
        self.distro_version = os_info.get("distribution_version", "")
        
        # Reuse existing cache or create new one
        if cache:
            self.cache = cache
        else:
            self.cache = CVECache()
        
        # Distribution-specific API endpoints
        # Ubuntu CVE Tracker API (more reliable than notices.json)
        self.ubuntu_api_url = "https://ubuntu.com/security/cve.json"
        self.ubuntu_notices_url = "https://ubuntu.com/security/notices.json"  # Fallback
        self.debian_tracker_url = "https://security-tracker.debian.org/tracker/data/json"
        
        # Cache for full advisory databases (downloaded once per session)
        self._advisory_cache: Optional[Any] = None  # Can be List[Dict] for Ubuntu or Dict for Debian
        self._advisory_cache_time: float = 0
    
    def check_cve_backport_status(
        self, 
        cve_id: str, 
        package_name: str, 
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """
        Check if a CVE has been backported/patched by the distribution.
        
        Args:
            cve_id: CVE ID (e.g., "CVE-2024-32002")
            package_name: Package name
            package_version: Package version
        
        Returns:
            Tuple of (is_patched, confidence_level)
            - is_patched: True if patched, False if vulnerable, None if unknown
            - confidence_level: "high", "medium", "low", or "unknown"
        """
        # Check cache first
        cache_key = f"distro_{cve_id}_{package_name}_{self.distro_id}"
        cached_result = self.cache.get(cache_key)
        if cached_result is not None:
            return cached_result.get("is_patched"), cached_result.get("confidence", "unknown")
        
        # Check based on distribution
        if self.distro_id == "ubuntu":
            result = self._check_ubuntu_security(cve_id, package_name, package_version)
        elif self.distro_id == "debian":
            result = self._check_debian_security(cve_id, package_name, package_version)
        else:
            # Unsupported distribution
            return None, "unknown"
        
        # Cache the result
        if result[0] is not None:  # Only cache if we got a definitive answer
            self.cache.set(cache_key, {
                "is_patched": result[0],
                "confidence": result[1],
                "checked_at": time.time()
            })
        
        return result
    
    def check_multiple_cves(
        self, 
        cve_package_pairs: List[Tuple[str, str, str]]
    ) -> Dict[str, Tuple[Optional[bool], str]]:
        """
        Batch check multiple CVE/package combinations efficiently.
        
        Args:
            cve_package_pairs: List of (cve_id, package_name, package_version) tuples
        
        Returns:
            Dictionary mapping CVE ID to (is_patched, confidence) tuple
        """
        results = {}
        
        # Load advisory database once (cached in memory for this batch)
        if self.distro_id == "ubuntu":
            advisory_db = self._load_ubuntu_advisories()
        elif self.distro_id == "debian":
            advisory_db = self._load_debian_advisories()
        else:
            advisory_db = None
        
        # Check each CVE using the loaded database
        for cve_id, package_name, package_version in cve_package_pairs:
            if advisory_db:
                # Use in-memory database for fast lookups
                if self.distro_id == "ubuntu":
                    result = self._check_ubuntu_security_with_db(
                        advisory_db, cve_id, package_name, package_version
                    )
                elif self.distro_id == "debian":
                    result = self._check_debian_security_with_db(
                        advisory_db, cve_id, package_name, package_version
                    )
                else:
                    result = None, "unknown"
            else:
                # Fallback to individual API calls
                result = self.check_cve_backport_status(cve_id, package_name, package_version)
            
            results[cve_id] = result
        
        return results
    
    def _check_ubuntu_security(
        self, 
        cve_id: str, 
        package_name: str, 
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """Check Ubuntu Security Notices (USN) for CVE status."""
        try:
            # Load Ubuntu advisories (cached)
            advisories = self._load_ubuntu_advisories()
            if not advisories:
                return None, "unknown"
            
            # Ubuntu API returns a list of notices
            # Each notice has: id, cves, releases, packages, etc.
            ubuntu_version = self._normalize_ubuntu_version(self.distro_version)
            
            # Search for CVE in advisories
            for notice in advisories:
                # Check if this notice mentions our CVE
                notice_cves = notice.get("cves", [])
                if cve_id not in notice_cves:
                    continue
                
                # Check releases for this Ubuntu version
                releases = notice.get("releases", {})
                if ubuntu_version not in releases:
                    continue
                
                release_info = releases[ubuntu_version]
                packages = release_info.get("packages", {})
                
                # Try exact package name match first
                if package_name in packages:
                    package_info = packages[package_name]
                    status = package_info.get("status", "").lower()
                    
                    if status in ["released", "not-affected"]:
                        return True, "high"  # Patched or not affected
                    elif status == "needed":
                        return False, "high"  # Still vulnerable
                    elif status == "deferred":
                        return None, "medium"  # Deferred, unclear
                
                # Try package name variations (Ubuntu sometimes uses different names)
                # e.g., "git" might be listed as "git-core" or vice versa
                for pkg_key in packages.keys():
                    # Check if package name is contained in key or vice versa
                    if (package_name in pkg_key or pkg_key in package_name) and len(package_name) > 3:
                        package_info = packages[pkg_key]
                        status = package_info.get("status", "").lower()
                        
                        if status in ["released", "not-affected"]:
                            return True, "medium"  # Patched (with lower confidence due to name mismatch)
                        elif status == "needed":
                            return False, "medium"  # Still vulnerable
            
            # CVE not found in advisories - might be too new or not tracked
            return None, "low"
            
        except Exception as e:
            # Silently fail - don't break the scan
            return None, "unknown"
    
    def _check_debian_security(
        self, 
        cve_id: str, 
        package_name: str, 
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """Check Debian Security Tracker for CVE status."""
        try:
            # Load Debian tracker data (cached)
            tracker_data = self._load_debian_advisories()
            if not tracker_data:
                return None, "unknown"
            
            # Debian tracker structure: {package: {cve: {version: status}}}
            if package_name in tracker_data:
                package_data = tracker_data[package_name]
                if cve_id in package_data:
                    cve_data = package_data[cve_id]
                    
                    # Check status for current Debian version
                    debian_version = self._normalize_debian_version(self.distro_version)
                    
                    # Look for status in version-specific entries
                    for version_key, status in cve_data.items():
                        if debian_version in version_key or version_key == "status":
                            status_lower = str(status).lower()
                            
                            if "resolved" in status_lower or "fixed" in status_lower:
                                return True, "high"
                            elif "open" in status_lower or "vulnerable" in status_lower:
                                return False, "high"
            
            return None, "low"
            
        except Exception:
            return None, "unknown"
    
    def _load_ubuntu_advisories(self) -> Optional[List[Dict[str, Any]]]:
        """Load Ubuntu security notices (cached in memory for session)."""
        # Check in-memory cache first
        if self._advisory_cache is not None:
            # Cache valid for 1 hour
            if time.time() - self._advisory_cache_time < 3600:
                return self._advisory_cache
        
        # Check file cache
        cache_key = f"ubuntu_advisories_{self.distro_version}"
        cached = self.cache.get(cache_key)
        if cached and isinstance(cached, list):
            self._advisory_cache = cached
            self._advisory_cache_time = time.time()
            return cached
        
        # Download from API - try CVE tracker first, then notices
        for api_url in [self.ubuntu_api_url, self.ubuntu_notices_url]:
            try:
                response = requests.get(api_url, timeout=30)
                response.raise_for_status()
                data = response.json()
                
                # Ubuntu CVE tracker format: {cve_id: {packages: {...}}}
                # Ubuntu notices format: [{id: "USN-...", cves: [...], releases: {...}}]
                if isinstance(data, dict) and any(k.startswith("CVE-") for k in data.keys()):
                    # CVE tracker format - convert to notices-like format for compatibility
                    advisories = self._convert_cve_tracker_to_notices(data)
                elif isinstance(data, list):
                    advisories = data
                elif isinstance(data, dict):
                    # Some APIs wrap it in a dict
                    advisories = data.get("notices", data.get("data", []))
                else:
                    advisories = []
                
                if advisories:
                    # Cache in memory and file
                    self._advisory_cache = advisories
                    self._advisory_cache_time = time.time()
                    self.cache.set(cache_key, advisories)
                    return advisories
            except Exception:
                continue  # Try next URL
        
        return None
    
    def _load_debian_advisories(self) -> Optional[Dict]:
        """Load Debian security tracker data (cached in memory for session)."""
        # Check in-memory cache first
        if self._advisory_cache is not None:
            if time.time() - self._advisory_cache_time < 3600:
                return self._advisory_cache
        
        # Check file cache
        cache_key = f"debian_tracker_{self.distro_version}"
        cached = self.cache.get(cache_key)
        if cached and isinstance(cached, dict):
            self._advisory_cache = cached
            self._advisory_cache_time = time.time()
            return cached
        
        # Download from API
        try:
            response = requests.get(self.debian_tracker_url, timeout=15)
            response.raise_for_status()
            tracker_data = response.json()
            
            # Cache in memory and file
            self._advisory_cache = tracker_data
            self._advisory_cache_time = time.time()
            self.cache.set(cache_key, tracker_data)
            
            return tracker_data
        except Exception:
            return None
    
    def _check_ubuntu_security_with_db(
        self,
        advisories: List[Dict[str, Any]],
        cve_id: str,
        package_name: str,
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """Check Ubuntu security using pre-loaded advisory database."""
        try:
            if not advisories:
                return None, "unknown"
            
            # Search for CVE in advisories
            for notice in advisories:
                if notice.get("id", "").startswith("USN-"):
                    cves = notice.get("cves", [])
                    if cve_id in cves:
                        # Check if this notice affects our package
                        releases = notice.get("releases", {})
                        
                        # Check current Ubuntu version
                        ubuntu_version = self._normalize_ubuntu_version(self.distro_version)
                        if ubuntu_version in releases:
                            release_info = releases[ubuntu_version]
                            
                            # Check if package is mentioned and status
                            packages = release_info.get("packages", {})
                            if package_name in packages:
                                package_info = packages[package_name]
                                status = package_info.get("status", "").lower()
                                
                                if status in ["released", "not-affected"]:
                                    return True, "high"  # Patched or not affected
                                elif status == "needed":
                                    return False, "high"  # Still vulnerable
                                elif status == "deferred":
                                    return None, "medium"  # Deferred, unclear
            
            # CVE not found in advisories - might be too new or not tracked
            return None, "low"
            
        except Exception:
            return None, "unknown"
    
    def _check_debian_security_with_db(
        self,
        tracker_data: Dict[str, Any],
        cve_id: str,
        package_name: str,
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """Check Debian security using pre-loaded tracker database."""
        try:
            if not tracker_data:
                return None, "unknown"
            
            # Debian tracker structure: {package: {cve: {version: status}}}
            if package_name in tracker_data:
                package_data = tracker_data[package_name]
                if cve_id in package_data:
                    cve_data = package_data[cve_id]
                    
                    # Check status for current Debian version
                    debian_version = self._normalize_debian_version(self.distro_version)
                    
                    # Look for status in version-specific entries
                    for version_key, status in cve_data.items():
                        if debian_version in version_key or version_key == "status":
                            status_lower = str(status).lower()
                            
                            if "resolved" in status_lower or "fixed" in status_lower:
                                return True, "high"
                            elif "open" in status_lower or "vulnerable" in status_lower:
                                return False, "high"
            
            return None, "low"
            
        except Exception:
            return None, "unknown"
    
    def _normalize_ubuntu_version(self, version: str) -> str:
        """Normalize Ubuntu version (e.g., '22.04' -> 'jammy' or 'noble')."""
        # Map common Ubuntu versions to codenames
        version_map = {
            "20.04": "focal",
            "22.04": "jammy",
            "24.04": "noble",
            "18.04": "bionic",
            "16.04": "xenial",
            "14.04": "trusty",
        }
        
        # Also map codenames to themselves (in case we already have codename)
        codename_map = {
            "focal": "focal",
            "jammy": "jammy",
            "noble": "noble",
            "bionic": "bionic",
            "xenial": "xenial",
            "trusty": "trusty",
        }
        
        version_lower = version.lower().strip()
        
        # Check if it's already a codename
        if version_lower in codename_map:
            return version_lower
        
        # Try direct mapping
        if version_lower in version_map:
            return version_map[version_lower]
        
        # Try to extract major.minor
        parts = version.split(".")
        if len(parts) >= 2:
            key = f"{parts[0]}.{parts[1]}"
            if key in version_map:
                return version_map[key]
        
        # Return as-is (might already be a codename or format we don't recognize)
        return version_lower
    
    def _normalize_debian_version(self, version: str) -> str:
        """Normalize Debian version (e.g., '12' -> 'bookworm')."""
        version_map = {
            "12": "bookworm",
            "11": "bullseye",
            "10": "buster",
            "9": "stretch",
        }
        
        if version in version_map:
            return version_map[version]
        
        return version.lower()
    
    def _convert_cve_tracker_to_notices(self, cve_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Convert Ubuntu CVE tracker format to notices-like format."""
        notices = []
        ubuntu_version = self._normalize_ubuntu_version(self.distro_version)
        
        for cve_id, cve_info in cve_data.items():
            if not cve_id.startswith("CVE-"):
                continue
            
            packages_info = cve_info.get("packages", {})
            if not packages_info:
                continue
            
            # Create a notice-like structure
            notice = {
                "id": f"CVE-{cve_id}",  # Use CVE as ID
                "cves": [cve_id],
                "releases": {}
            }
            
            # Process packages for this Ubuntu version
            release_packages = {}
            for pkg_name, pkg_info in packages_info.items():
                # Check if this package is fixed in our Ubuntu version
                ubuntu_status = pkg_info.get(ubuntu_version, {})
                if isinstance(ubuntu_status, dict):
                    status = ubuntu_status.get("status", "")
                    if status:
                        release_packages[pkg_name] = {"status": status}
            
            if release_packages:
                notice["releases"][ubuntu_version] = {"packages": release_packages}
                notices.append(notice)
        
        return notices