"""Distribution security advisory checking for backport detection."""

import time
from typing import Dict, List, Optional, Tuple, Any
import requests

from dav.vulnerability.cache import CVECache


class DistributionSecurityChecker:
    """Check distribution security advisories to detect backported fixes."""
    
    def __init__(self, os_info: Dict[str, Any], cache: Optional[CVECache] = None):
        """
        Initialize distribution security checker.
        
        Args:
            os_info: OS information dictionary
            cache: Optional CVE cache instance to reuse
        """
        self.os_info = os_info
        self.distro_id = os_info.get("distribution_id", "").lower()
        self.distro_version = os_info.get("distribution_version", "")
        
        # Reuse existing cache or create new one
        if cache:
            self.cache = cache
        else:
            self.cache = CVECache()
        
        # Distribution-specific API endpoints
        self.ubuntu_api_url = "https://ubuntu.com/security/notices.json"
        self.debian_tracker_url = "https://security-tracker.debian.org/tracker/data/json"
        
        # Cache for full advisory databases (downloaded once per session)
        self._advisory_cache: Optional[Any] = None  # Can be List[Dict] for Ubuntu or Dict for Debian
        self._advisory_cache_time: float = 0
    
    def check_cve_backport_status(
        self, 
        cve_id: str, 
        package_name: str, 
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """
        Check if a CVE has been backported/patched by the distribution.
        
        Args:
            cve_id: CVE ID (e.g., "CVE-2024-32002")
            package_name: Package name
            package_version: Package version
        
        Returns:
            Tuple of (is_patched, confidence_level)
            - is_patched: True if patched, False if vulnerable, None if unknown
            - confidence_level: "high", "medium", "low", or "unknown"
        """
        # Check cache first
        cache_key = f"distro_{cve_id}_{package_name}_{self.distro_id}"
        cached_result = self.cache.get(cache_key)
        if cached_result is not None:
            return cached_result.get("is_patched"), cached_result.get("confidence", "unknown")
        
        # Check based on distribution
        if self.distro_id == "ubuntu":
            result = self._check_ubuntu_security(cve_id, package_name, package_version)
        elif self.distro_id == "debian":
            result = self._check_debian_security(cve_id, package_name, package_version)
        else:
            # Unsupported distribution
            return None, "unknown"
        
        # Cache the result
        if result[0] is not None:  # Only cache if we got a definitive answer
            self.cache.set(cache_key, {
                "is_patched": result[0],
                "confidence": result[1],
                "checked_at": time.time()
            })
        
        return result
    
    def check_multiple_cves(
        self, 
        cve_package_pairs: List[Tuple[str, str, str]]
    ) -> Dict[str, Tuple[Optional[bool], str]]:
        """
        Batch check multiple CVE/package combinations efficiently.
        
        Args:
            cve_package_pairs: List of (cve_id, package_name, package_version) tuples
        
        Returns:
            Dictionary mapping CVE ID to (is_patched, confidence) tuple
        """
        results = {}
        
        # Load advisory database once (cached in memory for this batch)
        if self.distro_id == "ubuntu":
            advisory_db = self._load_ubuntu_advisories()
        elif self.distro_id == "debian":
            advisory_db = self._load_debian_advisories()
        else:
            advisory_db = None
        
        # Check each CVE using the loaded database
        for cve_id, package_name, package_version in cve_package_pairs:
            if advisory_db:
                # Use in-memory database for fast lookups
                if self.distro_id == "ubuntu":
                    result = self._check_ubuntu_security_with_db(
                        advisory_db, cve_id, package_name, package_version
                    )
                elif self.distro_id == "debian":
                    result = self._check_debian_security_with_db(
                        advisory_db, cve_id, package_name, package_version
                    )
                else:
                    result = None, "unknown"
            else:
                # Fallback to individual API calls
                result = self.check_cve_backport_status(cve_id, package_name, package_version)
            
            results[cve_id] = result
        
        return results
    
    def _check_ubuntu_security(
        self, 
        cve_id: str, 
        package_name: str, 
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """Check Ubuntu Security Notices (USN) for CVE status."""
        try:
            # Load Ubuntu advisories (cached)
            advisories = self._load_ubuntu_advisories()
            if not advisories:
                return None, "unknown"
            
            # Search for CVE in advisories
            for notice in advisories:
                if notice.get("id", "").startswith("USN-"):
                    cves = notice.get("cves", [])
                    if cve_id in cves:
                        # Check if this notice affects our package
                        releases = notice.get("releases", {})
                        
                        # Check current Ubuntu version
                        ubuntu_version = self._normalize_ubuntu_version(self.distro_version)
                        if ubuntu_version in releases:
                            release_info = releases[ubuntu_version]
                            
                            # Check if package is mentioned and status
                            packages = release_info.get("packages", {})
                            if package_name in packages:
                                package_info = packages[package_name]
                                status = package_info.get("status", "").lower()
                                
                                if status in ["released", "not-affected"]:
                                    return True, "high"  # Patched or not affected
                                elif status == "needed":
                                    return False, "high"  # Still vulnerable
                                elif status == "deferred":
                                    return None, "medium"  # Deferred, unclear
            
            # CVE not found in advisories - might be too new or not tracked
            return None, "low"
            
        except Exception:
            return None, "unknown"
    
    def _check_debian_security(
        self, 
        cve_id: str, 
        package_name: str, 
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """Check Debian Security Tracker for CVE status."""
        try:
            # Load Debian tracker data (cached)
            tracker_data = self._load_debian_advisories()
            if not tracker_data:
                return None, "unknown"
            
            # Debian tracker structure: {package: {cve: {version: status}}}
            if package_name in tracker_data:
                package_data = tracker_data[package_name]
                if cve_id in package_data:
                    cve_data = package_data[cve_id]
                    
                    # Check status for current Debian version
                    debian_version = self._normalize_debian_version(self.distro_version)
                    
                    # Look for status in version-specific entries
                    for version_key, status in cve_data.items():
                        if debian_version in version_key or version_key == "status":
                            status_lower = str(status).lower()
                            
                            if "resolved" in status_lower or "fixed" in status_lower:
                                return True, "high"
                            elif "open" in status_lower or "vulnerable" in status_lower:
                                return False, "high"
            
            return None, "low"
            
        except Exception:
            return None, "unknown"
    
    def _load_ubuntu_advisories(self) -> Optional[List[Dict]]:
        """Load Ubuntu security notices (cached in memory for session)."""
        # Check in-memory cache first
        if self._advisory_cache is not None:
            # Cache valid for 1 hour
            if time.time() - self._advisory_cache_time < 3600:
                return self._advisory_cache
        
        # Check file cache
        cache_key = f"ubuntu_advisories_{self.distro_version}"
        cached = self.cache.get(cache_key)
        if cached and isinstance(cached, list):
            self._advisory_cache = cached
            self._advisory_cache_time = time.time()
            return cached
        
        # Download from API
        try:
            response = requests.get(self.ubuntu_api_url, timeout=10)
            response.raise_for_status()
            advisories = response.json()
            
            # Cache in memory and file
            self._advisory_cache = advisories
            self._advisory_cache_time = time.time()
            self.cache.set(cache_key, advisories)
            
            return advisories
        except Exception:
            return None
    
    def _load_debian_advisories(self) -> Optional[Dict]:
        """Load Debian security tracker data (cached in memory for session)."""
        # Check in-memory cache first
        if self._advisory_cache is not None:
            if time.time() - self._advisory_cache_time < 3600:
                return self._advisory_cache
        
        # Check file cache
        cache_key = f"debian_tracker_{self.distro_version}"
        cached = self.cache.get(cache_key)
        if cached and isinstance(cached, dict):
            self._advisory_cache = cached
            self._advisory_cache_time = time.time()
            return cached
        
        # Download from API
        try:
            response = requests.get(self.debian_tracker_url, timeout=15)
            response.raise_for_status()
            tracker_data = response.json()
            
            # Cache in memory and file
            self._advisory_cache = tracker_data
            self._advisory_cache_time = time.time()
            self.cache.set(cache_key, tracker_data)
            
            return tracker_data
        except Exception:
            return None
    
    def _check_ubuntu_security_with_db(
        self,
        advisories: List[Dict[str, Any]],
        cve_id: str,
        package_name: str,
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """Check Ubuntu security using pre-loaded advisory database."""
        try:
            if not advisories:
                return None, "unknown"
            
            # Search for CVE in advisories
            for notice in advisories:
                if notice.get("id", "").startswith("USN-"):
                    cves = notice.get("cves", [])
                    if cve_id in cves:
                        # Check if this notice affects our package
                        releases = notice.get("releases", {})
                        
                        # Check current Ubuntu version
                        ubuntu_version = self._normalize_ubuntu_version(self.distro_version)
                        if ubuntu_version in releases:
                            release_info = releases[ubuntu_version]
                            
                            # Check if package is mentioned and status
                            packages = release_info.get("packages", {})
                            if package_name in packages:
                                package_info = packages[package_name]
                                status = package_info.get("status", "").lower()
                                
                                if status in ["released", "not-affected"]:
                                    return True, "high"  # Patched or not affected
                                elif status == "needed":
                                    return False, "high"  # Still vulnerable
                                elif status == "deferred":
                                    return None, "medium"  # Deferred, unclear
            
            # CVE not found in advisories - might be too new or not tracked
            return None, "low"
            
        except Exception:
            return None, "unknown"
    
    def _check_debian_security_with_db(
        self,
        tracker_data: Dict[str, Any],
        cve_id: str,
        package_name: str,
        package_version: str
    ) -> Tuple[Optional[bool], str]:
        """Check Debian security using pre-loaded tracker database."""
        try:
            if not tracker_data:
                return None, "unknown"
            
            # Debian tracker structure: {package: {cve: {version: status}}}
            if package_name in tracker_data:
                package_data = tracker_data[package_name]
                if cve_id in package_data:
                    cve_data = package_data[cve_id]
                    
                    # Check status for current Debian version
                    debian_version = self._normalize_debian_version(self.distro_version)
                    
                    # Look for status in version-specific entries
                    for version_key, status in cve_data.items():
                        if debian_version in version_key or version_key == "status":
                            status_lower = str(status).lower()
                            
                            if "resolved" in status_lower or "fixed" in status_lower:
                                return True, "high"
                            elif "open" in status_lower or "vulnerable" in status_lower:
                                return False, "high"
            
            return None, "low"
            
        except Exception:
            return None, "unknown"
    
    def _normalize_ubuntu_version(self, version: str) -> str:
        """Normalize Ubuntu version (e.g., '22.04' -> 'jammy')."""
        # Map common Ubuntu versions
        version_map = {
            "20.04": "focal",
            "22.04": "jammy",
            "24.04": "noble",
            "18.04": "bionic",
            "16.04": "xenial",
        }
        
        # Try direct mapping
        if version in version_map:
            return version_map[version]
        
        # Try to extract major.minor
        parts = version.split(".")
        if len(parts) >= 2:
            key = f"{parts[0]}.{parts[1]}"
            if key in version_map:
                return version_map[key]
        
        return version.lower()
    
    def _normalize_debian_version(self, version: str) -> str:
        """Normalize Debian version (e.g., '12' -> 'bookworm')."""
        version_map = {
            "12": "bookworm",
            "11": "bullseye",
            "10": "buster",
            "9": "stretch",
        }
        
        if version in version_map:
            return version_map[version]
        
        return version.lower()
