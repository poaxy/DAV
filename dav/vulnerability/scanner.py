"""Main vulnerability scanner engine."""

from typing import Dict, List, Any, Optional, Callable
from packaging import version as pkg_version

from dav.vulnerability.inventory import PackageInventory
from dav.vulnerability.nvd_client import NVDClient
from dav.vulnerability.cpe_mapper import CPEMapper
from dav.vulnerability.cache import CVECache


class VulnerabilityScanner:
    """Main vulnerability scanner."""
    
    def __init__(self, nvd_api_key: Optional[str] = None):
        """
        Initialize vulnerability scanner.
        
        Args:
            nvd_api_key: Optional NVD API key for paid tier
        """
        self.inventory = PackageInventory()
        self.nvd_client = NVDClient(api_key=nvd_api_key)
        self.cpe_mapper = CPEMapper()
        self.cache = CVECache()
    
    def scan_system(self, progress_callback: Optional[Callable[[int, int, str], None]] = None, core_only: bool = False) -> Dict[str, Any]:
        """
        Scan system for vulnerabilities.
        
        Args:
            progress_callback: Optional callback function(current, total, package_name)
            core_only: If True, scan only core security-critical packages
        
        Returns:
            Dictionary with scan results:
            {
                "status": "success" | "error",
                "total_packages_scanned": int,
                "vulnerabilities_found": int,
                "vulnerabilities": [...],
                "summary": {...}
            }
        """
        # Step 1: Collect packages
        if core_only:
            inventory = self.inventory.collect_core_packages()
        else:
            inventory = self.inventory.collect_all_packages()
        all_packages = []
        all_packages.extend(inventory.get("system_packages", []))
        all_packages.extend(inventory.get("python_packages", []))
        
        if not all_packages:
            return {
                "status": "error",
                "message": "No packages found to scan",
                "total_packages_scanned": 0,
                "vulnerabilities_found": 0,
                "vulnerabilities": [],
                "summary": {"critical": 0, "high": 0, "medium": 0, "low": 0, "total": 0}
            }
        
        # Step 2: Scan packages
        vulnerabilities = []
        scanned_count = 0
        api_calls_made = 0
        api_calls_succeeded = 0
        api_calls_failed = 0
        cache_hits = 0
        cache_misses = 0
        packages_skipped = 0
        errors = []
        
        for package in all_packages:
            if progress_callback:
                progress_callback(scanned_count, len(all_packages), package["name"])
            
            # Convert to CPE
            cpe = self.cpe_mapper.package_to_cpe(package, inventory["os_info"])
            if not cpe:
                packages_skipped += 1
                scanned_count += 1
                continue
            
            # Check cache first
            cached_result = self.cache.get(cpe)
            if cached_result is not None:
                # Use cached result (it's a list of CVE dicts)
                cves = cached_result if isinstance(cached_result, list) else []
                cache_hits += 1
            else:
                # Query NVD API
                cache_misses += 1
                api_calls_made += 1
                cves, error = self.nvd_client.search_by_cpe(cpe, results_per_page=5)
                
                if error:
                    api_calls_failed += 1
                    errors.append(f"{package['name']} ({cpe}): {error}")
                    # Don't cache failed API calls - allow retry on next scan
                else:
                    api_calls_succeeded += 1
                    # Only cache successful API responses (even if empty - means no CVEs found)
                    self.cache.set(cpe, cves)
            
            # Process CVEs
            for cve in cves:
                if self._is_vulnerable(package, cve):
                    vulnerabilities.append({
                        "cve_id": cve.get("id"),
                        "package": package["name"],
                        "package_version": package["version"],
                        "severity": self._extract_severity(cve),
                        "description": self._extract_description(cve),
                        "cvss_score": self._extract_cvss_score(cve),
                        "published_date": cve.get("published"),
                        "references": self._extract_references(cve)
                    })
            
            scanned_count += 1
        
        # Step 3: Sort by severity (CVSS score)
        vulnerabilities.sort(key=lambda x: x.get("cvss_score", 0), reverse=True)
        
        # Step 4: Generate summary
        summary = self._generate_summary(vulnerabilities)
        
        return {
            "status": "success",
            "total_packages_scanned": scanned_count,
            "vulnerabilities_found": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "summary": summary,
            "statistics": {
                "api_calls_made": api_calls_made,
                "api_calls_succeeded": api_calls_succeeded,
                "api_calls_failed": api_calls_failed,
                "cache_hits": cache_hits,
                "cache_misses": cache_misses,
                "packages_skipped": packages_skipped,
                "errors": errors
            }
        }
    
    def _is_vulnerable(self, package: Dict[str, str], cve: Dict[str, Any]) -> bool:
        """
        Check if package version is vulnerable.
        
        Parses CVE configurations to check if the package version falls within
        affected version ranges. Note: This may produce false positives for
        distributions that backport security fixes without bumping version numbers.
        
        Args:
            package: Package dictionary with 'name' and 'version'
            cve: CVE dictionary from NVD API
        
        Returns:
            True if package version appears to be vulnerable
        """
        package_version = package.get("version", "")
        if not package_version:
            return False
        
        # Extract base version (remove Debian/Ubuntu package suffixes)
        # e.g., "1:2.43.0-1ubuntu7.3" -> "2.43.0"
        base_version = self._extract_base_version(package_version)
        if not base_version:
            return False
        
        # Check CVE configurations for affected versions
        configurations = cve.get("configurations", [])
        if not configurations:
            # No configuration data - assume vulnerable if CVE exists for this CPE
            return True
        
        # Parse configurations to find affected version ranges
        for config in configurations:
            nodes = config.get("nodes", [])
            for node in nodes:
                if self._check_node_affects_version(node, base_version, package.get("name", "")):
                    return True
        
        # If we can't determine from configurations, be conservative
        # (CVE exists for this CPE, so assume potentially vulnerable)
        return True
    
    def _extract_base_version(self, version: str) -> Optional[str]:
        """
        Extract base version from package version string.
        
        Handles formats like:
        - "1:2.43.0-1ubuntu7.3" -> "2.43.0"
        - "2.43.0" -> "2.43.0"
        - "2.43.0-1" -> "2.43.0"
        
        Args:
            version: Package version string
        
        Returns:
            Base version string or None
        """
        import re
        
        # Remove epoch (everything before first colon)
        if ":" in version:
            version = version.split(":", 1)[1]
        
        # Remove Debian/Ubuntu suffix (everything after first dash that's not part of version)
        # But keep version numbers that might have dashes
        # Simple approach: split on dash and take first part if it looks like a version
        parts = version.split("-")
        base = parts[0]
        
        # Validate it looks like a version (has at least one digit)
        if re.search(r'\d', base):
            return base
        
        return None
    
    def _check_node_affects_version(self, node: Dict[str, Any], package_version: str, package_name: str) -> bool:
        """
        Check if a CVE configuration node affects the package version.
        
        Args:
            node: CVE configuration node
            package_version: Base package version to check
            package_name: Package name (for matching)
        
        Returns:
            True if version appears to be affected
        """
        # Check if this node matches our package
        cpe_match = node.get("cpeMatch", [])
        for match in cpe_match:
            # Check if vulnerable (not fixed)
            vulnerable = match.get("vulnerable", False)
            if not vulnerable:
                continue
            
            # Get version range
            version_start_including = match.get("versionStartIncluding")
            version_start_excluding = match.get("versionStartExcluding")
            version_end_including = match.get("versionEndIncluding")
            version_end_excluding = match.get("versionEndExcluding")
            
            # If no version constraints, assume all versions affected
            if not any([version_start_including, version_start_excluding, 
                       version_end_including, version_end_excluding]):
                return True
            
            # Compare version against range
            if self._version_in_range(package_version, 
                                     version_start_including, version_start_excluding,
                                     version_end_including, version_end_excluding):
                return True
        
        return False
    
    def _version_in_range(self, version: str, 
                         start_inc: Optional[str], start_exc: Optional[str],
                         end_inc: Optional[str], end_exc: Optional[str]) -> bool:
        """
        Check if version falls within the specified range.
        
        Args:
            version: Version to check
            start_inc: Start version (inclusive)
            start_exc: Start version (exclusive)
            end_inc: End version (inclusive)
            end_exc: End version (exclusive)
        
        Returns:
            True if version is in range
        """
        try:
            v = pkg_version.parse(version)
            
            if start_inc:
                if v < pkg_version.parse(start_inc):
                    return False
            if start_exc:
                if v <= pkg_version.parse(start_exc):
                    return False
            if end_inc:
                if v > pkg_version.parse(end_inc):
                    return False
            if end_exc:
                if v >= pkg_version.parse(end_exc):
                    return False
            
            return True
        except Exception:
            # If version parsing fails, be conservative (assume vulnerable)
            return True
    
    def _extract_severity(self, cve: Dict[str, Any]) -> str:
        """Extract severity from CVE data."""
        metrics = cve.get("metrics", {})
        
        # Try CVSS v3.1 first
        if "cvssMetricV31" in metrics and metrics["cvssMetricV31"]:
            return metrics["cvssMetricV31"][0].get("cvssData", {}).get("baseSeverity", "UNKNOWN")
        
        # Try CVSS v3.0
        if "cvssMetricV30" in metrics and metrics["cvssMetricV30"]:
            return metrics["cvssMetricV30"][0].get("cvssData", {}).get("baseSeverity", "UNKNOWN")
        
        # Try CVSS v2
        if "cvssMetricV2" in metrics and metrics["cvssMetricV2"]:
            return metrics["cvssMetricV2"][0].get("baseSeverity", "UNKNOWN")
        
        return "UNKNOWN"
    
    def _extract_cvss_score(self, cve: Dict[str, Any]) -> float:
        """Extract CVSS score from CVE data."""
        metrics = cve.get("metrics", {})
        
        # Try CVSS v3.1 first
        if "cvssMetricV31" in metrics and metrics["cvssMetricV31"]:
            score = metrics["cvssMetricV31"][0].get("cvssData", {}).get("baseScore", 0)
            if score:
                return float(score)
        
        # Try CVSS v3.0
        if "cvssMetricV30" in metrics and metrics["cvssMetricV30"]:
            score = metrics["cvssMetricV30"][0].get("cvssData", {}).get("baseScore", 0)
            if score:
                return float(score)
        
        # Try CVSS v2
        if "cvssMetricV2" in metrics and metrics["cvssMetricV2"]:
            score = metrics["cvssMetricV2"][0].get("cvssData", {}).get("baseScore", 0)
            if score:
                return float(score)
        
        return 0.0
    
    def _extract_description(self, cve: Dict[str, Any]) -> str:
        """Extract CVE description."""
        descriptions = cve.get("descriptions", [])
        for desc in descriptions:
            if desc.get("lang") == "en":
                return desc.get("value", "")
        return "No description available"
    
    def _extract_references(self, cve: Dict[str, Any]) -> List[str]:
        """Extract reference URLs."""
        references = cve.get("references", [])
        return [ref.get("url", "") for ref in references if ref.get("url")]
    
    def _generate_summary(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, int]:
        """Generate summary statistics."""
        severity_counts = {
            "CRITICAL": 0,
            "HIGH": 0,
            "MEDIUM": 0,
            "LOW": 0,
            "UNKNOWN": 0
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "UNKNOWN")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        return {
            "critical": severity_counts["CRITICAL"],
            "high": severity_counts["HIGH"],
            "medium": severity_counts["MEDIUM"],
            "low": severity_counts["LOW"],
            "total": len(vulnerabilities)
        }
