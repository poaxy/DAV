"""Main vulnerability scanner engine."""

import re
from typing import Dict, List, Any, Optional, Callable
from packaging import version as pkg_version

from dav.vulnerability.inventory import PackageInventory
from dav.vulnerability.nvd_client import NVDClient
from dav.vulnerability.cpe_mapper import CPEMapper
from dav.vulnerability.cache import CVECache
from dav.vulnerability.distro_security import DistributionSecurityChecker
from dav.vulnerability.utils import (
    extract_severity_from_cve,
    extract_cvss_score_from_cve,
    extract_description_from_cve,
    extract_references_from_cve,
)


class VulnerabilityScanner:
    """Main vulnerability scanner."""
    
    def __init__(self, nvd_api_key: Optional[str] = None):
        """
        Initialize vulnerability scanner.
        
        Args:
            nvd_api_key: Optional NVD API key for paid tier
        """
        self.inventory = PackageInventory()
        self.nvd_client = NVDClient(api_key=nvd_api_key)
        self.cpe_mapper = CPEMapper()
        self.cache = CVECache()
        # Distribution security checker (lazy initialization)
        self._distro_checker: Optional[DistributionSecurityChecker] = None
    
    def scan_system(self, progress_callback: Optional[Callable[[int, int, str], None]] = None, core_only: bool = False) -> Dict[str, Any]:
        """
        Scan system for vulnerabilities.
        
        Args:
            progress_callback: Optional callback function(current, total, package_name)
            core_only: If True, scan only core security-critical packages
        
        Returns:
            Dictionary with scan results:
            {
                "status": "success" | "error",
                "total_packages_scanned": int,
                "vulnerabilities_found": int,
                "vulnerabilities": [...],
                "summary": {...}
            }
        """
        # Step 1: Collect packages
        if core_only:
            inventory = self.inventory.collect_core_packages()
        else:
            inventory = self.inventory.collect_all_packages()
        all_packages = []
        all_packages.extend(inventory.get("system_packages", []))
        all_packages.extend(inventory.get("python_packages", []))
        
        if not all_packages:
            return {
                "status": "error",
                "message": "No packages found to scan",
                "total_packages_scanned": 0,
                "vulnerabilities_found": 0,
                "vulnerabilities": [],
                "summary": {"critical": 0, "high": 0, "medium": 0, "low": 0, "total": 0}
            }
        
        # Step 2: Scan packages
        vulnerabilities = []
        scanned_count = 0
        api_calls_made = 0
        api_calls_succeeded = 0
        api_calls_failed = 0
        cache_hits = 0
        cache_misses = 0
        packages_skipped = 0
        errors = []
        
        for package in all_packages:
            if progress_callback:
                progress_callback(scanned_count, len(all_packages), package["name"])
            
            # Convert to CPE
            cpe = self.cpe_mapper.package_to_cpe(package, inventory["os_info"])
            if not cpe:
                packages_skipped += 1
                scanned_count += 1
                continue
            
            # Check cache first
            cached_result = self.cache.get(cpe)
            if cached_result is not None:
                # Use cached result (it's a list of CVE dicts)
                cves = cached_result if isinstance(cached_result, list) else []
                cache_hits += 1
            else:
                # Query NVD API
                cache_misses += 1
                api_calls_made += 1
                cves, error = self.nvd_client.search_by_cpe(cpe, results_per_page=5)
                
                if error:
                    api_calls_failed += 1
                    errors.append(f"{package['name']} ({cpe}): {error}")
                    # Don't cache failed API calls - allow retry on next scan
                else:
                    api_calls_succeeded += 1
                    # Only cache successful API responses (even if empty - means no CVEs found)
                    self.cache.set(cpe, cves)
            
            # Process CVEs
            for cve in cves:
                if self._is_vulnerable(package, cve):
                    vulnerabilities.append({
                        "cve_id": cve.get("id"),
                        "package": package["name"],
                        "package_version": package["version"],
                        "severity": extract_severity_from_cve(cve),
                        "description": extract_description_from_cve(cve),
                        "cvss_score": extract_cvss_score_from_cve(cve),
                        "published_date": cve.get("published"),
                        "references": extract_references_from_cve(cve)
                    })
            
            scanned_count += 1
        
        # Step 3: Check distribution security advisories for backports (post-process)
        # Only check CVEs we found - this is efficient and doesn't slow down initial scan
        if vulnerabilities:
            vulnerabilities = self._check_distribution_backports(vulnerabilities, inventory["os_info"])
        
        # Step 4: Sort by severity (CVSS score)
        vulnerabilities.sort(key=lambda x: x.get("cvss_score", 0), reverse=True)
        
        # Step 5: Generate summary
        summary = self._generate_summary(vulnerabilities)
        
        return {
            "status": "success",
            "total_packages_scanned": scanned_count,
            "vulnerabilities_found": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "summary": summary,
            "statistics": {
                "api_calls_made": api_calls_made,
                "api_calls_succeeded": api_calls_succeeded,
                "api_calls_failed": api_calls_failed,
                "cache_hits": cache_hits,
                "cache_misses": cache_misses,
                "packages_skipped": packages_skipped,
                "errors": errors
            }
        }
    
    def _is_vulnerable(self, package: Dict[str, str], cve: Dict[str, Any]) -> bool:
        """
        Check if package version is vulnerable.
        
        Parses CVE configurations to check if the package version falls within
        affected version ranges. Note: This may produce false positives for
        distributions that backport security fixes without bumping version numbers.
        
        Args:
            package: Package dictionary with 'name' and 'version'
            cve: CVE dictionary from NVD API
        
        Returns:
            True if package version appears to be vulnerable
        """
        package_version = package.get("version", "")
        if not package_version:
            return False
        
        # Extract base version (remove Debian/Ubuntu package suffixes)
        # e.g., "1:2.43.0-1ubuntu7.3" -> "2.43.0"
        base_version = self._extract_base_version(package_version)
        if not base_version:
            return False
        
        # Check CVE configurations for affected versions
        configurations = cve.get("configurations", [])
        if not configurations:
            # No configuration data - assume vulnerable if CVE exists for this CPE
            return True
        
        # Parse configurations to find affected version ranges
        for config in configurations:
            nodes = config.get("nodes", [])
            for node in nodes:
                if self._check_node_affects_version(node, base_version, package.get("name", "")):
                    return True
        
        # If we can't determine from configurations, be conservative
        # (CVE exists for this CPE, so assume potentially vulnerable)
        return True
    
    def _extract_base_version(self, version: str) -> Optional[str]:
        """
        Extract base version from package version string.
        
        Handles formats like:
        - "1:2.43.0-1ubuntu7.3" -> "2.43.0"
        - "2.43.0" -> "2.43.0"
        - "2.43.0-1" -> "2.43.0"
        
        Args:
            version: Package version string
        
        Returns:
            Base version string or None
        """
        # Remove epoch (everything before first colon)
        if ":" in version:
            version = version.split(":", 1)[1]
        
        # Remove Debian/Ubuntu suffix (everything after first dash that's not part of version)
        # But keep version numbers that might have dashes
        # Simple approach: split on dash and take first part if it looks like a version
        parts = version.split("-")
        base = parts[0]
        
        # Validate it looks like a version (has at least one digit)
        if re.search(r'\d', base):
            return base
        
        return None
    
    def _check_node_affects_version(self, node: Dict[str, Any], package_version: str, package_name: str) -> bool:
        """
        Check if a CVE configuration node affects the package version.
        
        Args:
            node: CVE configuration node
            package_version: Base package version to check
            package_name: Package name (for matching)
        
        Returns:
            True if version appears to be affected
        """
        # Check if this node matches our package
        cpe_match = node.get("cpeMatch", [])
        for match in cpe_match:
            # Check if vulnerable (not fixed)
            vulnerable = match.get("vulnerable", False)
            if not vulnerable:
                continue
            
            # Get version range
            version_start_including = match.get("versionStartIncluding")
            version_start_excluding = match.get("versionStartExcluding")
            version_end_including = match.get("versionEndIncluding")
            version_end_excluding = match.get("versionEndExcluding")
            
            # If no version constraints, assume all versions affected
            if not any([version_start_including, version_start_excluding, 
                       version_end_including, version_end_excluding]):
                return True
            
            # Compare version against range
            if self._version_in_range(package_version, 
                                     version_start_including, version_start_excluding,
                                     version_end_including, version_end_excluding):
                return True
        
        return False
    
    def _version_in_range(self, version: str, 
                         start_inc: Optional[str], start_exc: Optional[str],
                         end_inc: Optional[str], end_exc: Optional[str]) -> bool:
        """
        Check if version falls within the specified range.
        
        Args:
            version: Version to check
            start_inc: Start version (inclusive)
            start_exc: Start version (exclusive)
            end_inc: End version (inclusive)
            end_exc: End version (exclusive)
        
        Returns:
            True if version is in range
        """
        try:
            v = pkg_version.parse(version)
            
            if start_inc:
                if v < pkg_version.parse(start_inc):
                    return False
            if start_exc:
                if v <= pkg_version.parse(start_exc):
                    return False
            if end_inc:
                if v > pkg_version.parse(end_inc):
                    return False
            if end_exc:
                if v >= pkg_version.parse(end_exc):
                    return False
            
            return True
        except Exception:
            # If version parsing fails, be conservative (assume vulnerable)
            return True
    
    def _generate_summary(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, int]:
        """Generate summary statistics."""
        severity_counts = {
            "CRITICAL": 0,
            "HIGH": 0,
            "MEDIUM": 0,
            "LOW": 0,
            "UNKNOWN": 0
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "UNKNOWN")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        return {
            "critical": severity_counts["CRITICAL"],
            "high": severity_counts["HIGH"],
            "medium": severity_counts["MEDIUM"],
            "low": severity_counts["LOW"],
            "total": len(vulnerabilities)
        }
    
    def _check_distribution_backports(
        self, 
        vulnerabilities: List[Dict[str, Any]], 
        os_info: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Check distribution security advisories to filter out backported fixes.
        
        This is a post-processing step that only checks CVEs we've already found,
        so it doesn't slow down the initial scan.
        
        Args:
            vulnerabilities: List of vulnerability dictionaries
            os_info: OS information dictionary
        
        Returns:
            Filtered list of vulnerabilities (backported ones marked or removed)
        """
        # Only check for Ubuntu/Debian (other distros not supported yet)
        distro_id = os_info.get("distribution_id", "").lower()
        if distro_id not in ["ubuntu", "debian"]:
            return vulnerabilities
        
        # Initialize distribution checker (lazy)
        if self._distro_checker is None:
            self._distro_checker = DistributionSecurityChecker(os_info, cache=self.cache)
        
        # Prepare batch check - collect unique CVE/package pairs
        cve_package_pairs = []
        seen_pairs = set()
        
        for vuln in vulnerabilities:
            cve_id = vuln.get("cve_id", "")
            package_name = vuln.get("package", "")
            package_version = vuln.get("package_version", "")
            
            if cve_id and package_name:
                key = (cve_id, package_name)
                if key not in seen_pairs:
                    cve_package_pairs.append((cve_id, package_name, package_version))
                    seen_pairs.add(key)
        
        # Batch check all CVEs at once (efficient!)
        if cve_package_pairs:
            backport_status = self._distro_checker.check_multiple_cves(cve_package_pairs)
            
            # Update vulnerabilities with backport status
            filtered_vulns = []
            for vuln in vulnerabilities:
                cve_id = vuln.get("cve_id", "")
                package_name = vuln.get("package", "")
                key = (cve_id, package_name)
                
                if key in backport_status:
                    is_patched, confidence = backport_status[key]
                    
                    if is_patched is True:
                        # CVE has been backported - mark it but don't remove (show user it's patched)
                        vuln["backport_status"] = "patched"
                        vuln["backport_confidence"] = confidence
                        # Still include it but marked as patched
                        filtered_vulns.append(vuln)
                    elif is_patched is False:
                        # Confirmed vulnerable (not patched)
                        vuln["backport_status"] = "vulnerable"
                        vuln["backport_confidence"] = confidence
                        filtered_vulns.append(vuln)
                    else:
                        # Unknown status - include it but mark as uncertain
                        vuln["backport_status"] = "unknown"
                        vuln["backport_confidence"] = confidence
                        filtered_vulns.append(vuln)
                else:
                    # No backport info available
                    vuln["backport_status"] = "unknown"
                    vuln["backport_confidence"] = "unknown"
                    filtered_vulns.append(vuln)
            
            return filtered_vulns
        
        return vulnerabilities