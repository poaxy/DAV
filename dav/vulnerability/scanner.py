"""Main vulnerability scanner engine."""

from typing import Dict, List, Any, Optional, Callable

from dav.vulnerability.inventory import PackageInventory
from dav.vulnerability.nvd_client import NVDClient
from dav.vulnerability.cpe_mapper import CPEMapper
from dav.vulnerability.cache import CVECache


class VulnerabilityScanner:
    """Main vulnerability scanner."""
    
    def __init__(self, nvd_api_key: Optional[str] = None):
        """
        Initialize vulnerability scanner.
        
        Args:
            nvd_api_key: Optional NVD API key for paid tier
        """
        self.inventory = PackageInventory()
        self.nvd_client = NVDClient(api_key=nvd_api_key)
        self.cpe_mapper = CPEMapper()
        self.cache = CVECache()
    
    def scan_system(self, progress_callback: Optional[Callable[[int, int, str], None]] = None, core_only: bool = False) -> Dict[str, Any]:
        """
        Scan system for vulnerabilities.
        
        Args:
            progress_callback: Optional callback function(current, total, package_name)
            core_only: If True, scan only core security-critical packages
        
        Returns:
            Dictionary with scan results:
            {
                "status": "success" | "error",
                "total_packages_scanned": int,
                "vulnerabilities_found": int,
                "vulnerabilities": [...],
                "summary": {...}
            }
        """
        # Step 1: Collect packages
        if core_only:
            inventory = self.inventory.collect_core_packages()
        else:
            inventory = self.inventory.collect_all_packages()
        all_packages = []
        all_packages.extend(inventory.get("system_packages", []))
        all_packages.extend(inventory.get("python_packages", []))
        
        if not all_packages:
            return {
                "status": "error",
                "message": "No packages found to scan",
                "total_packages_scanned": 0,
                "vulnerabilities_found": 0,
                "vulnerabilities": [],
                "summary": {"critical": 0, "high": 0, "medium": 0, "low": 0, "total": 0}
            }
        
        # Step 2: Scan packages
        vulnerabilities = []
        scanned_count = 0
        api_calls_made = 0
        api_calls_succeeded = 0
        api_calls_failed = 0
        cache_hits = 0
        cache_misses = 0
        packages_skipped = 0
        errors = []
        
        for package in all_packages:
            if progress_callback:
                progress_callback(scanned_count, len(all_packages), package["name"])
            
            # Convert to CPE
            cpe = self.cpe_mapper.package_to_cpe(package, inventory["os_info"])
            if not cpe:
                packages_skipped += 1
                scanned_count += 1
                continue
            
            # Check cache first
            cached_result = self.cache.get(cpe)
            if cached_result is not None:
                # Use cached result (it's a list of CVE dicts)
                cves = cached_result if isinstance(cached_result, list) else []
                cache_hits += 1
            else:
                # Query NVD API
                cache_misses += 1
                api_calls_made += 1
                cves, error = self.nvd_client.search_by_cpe(cpe, results_per_page=5)
                
                if error:
                    api_calls_failed += 1
                    errors.append(f"{package['name']} ({cpe}): {error}")
                    # Don't cache failed API calls - allow retry on next scan
                else:
                    api_calls_succeeded += 1
                    # Only cache successful API responses (even if empty - means no CVEs found)
                    self.cache.set(cpe, cves)
            
            # Process CVEs
            for cve in cves:
                if self._is_vulnerable(package, cve):
                    vulnerabilities.append({
                        "cve_id": cve.get("id"),
                        "package": package["name"],
                        "package_version": package["version"],
                        "severity": self._extract_severity(cve),
                        "description": self._extract_description(cve),
                        "cvss_score": self._extract_cvss_score(cve),
                        "published_date": cve.get("published"),
                        "references": self._extract_references(cve)
                    })
            
            scanned_count += 1
        
        # Step 3: Sort by severity (CVSS score)
        vulnerabilities.sort(key=lambda x: x.get("cvss_score", 0), reverse=True)
        
        # Step 4: Generate summary
        summary = self._generate_summary(vulnerabilities)
        
        return {
            "status": "success",
            "total_packages_scanned": scanned_count,
            "vulnerabilities_found": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "summary": summary,
            "statistics": {
                "api_calls_made": api_calls_made,
                "api_calls_succeeded": api_calls_succeeded,
                "api_calls_failed": api_calls_failed,
                "cache_hits": cache_hits,
                "cache_misses": cache_misses,
                "packages_skipped": packages_skipped,
                "errors": errors
            }
        }
    
    def _is_vulnerable(self, package: Dict[str, str], cve: Dict[str, Any]) -> bool:
        """
        Check if package version is vulnerable.
        
        Note: This is a simplified check that assumes if a CVE exists for the CPE,
        the package is vulnerable. A full implementation would parse version ranges
        from CVE configurations to determine exact affected versions.
        
        Args:
            package: Package dictionary
            cve: CVE dictionary
        
        Returns:
            True if package is potentially vulnerable
        """
        # If CVE exists for this CPE, assume vulnerability applies
        return True
    
    def _extract_severity(self, cve: Dict[str, Any]) -> str:
        """Extract severity from CVE data."""
        metrics = cve.get("metrics", {})
        
        # Try CVSS v3.1 first
        if "cvssMetricV31" in metrics and metrics["cvssMetricV31"]:
            return metrics["cvssMetricV31"][0].get("cvssData", {}).get("baseSeverity", "UNKNOWN")
        
        # Try CVSS v3.0
        if "cvssMetricV30" in metrics and metrics["cvssMetricV30"]:
            return metrics["cvssMetricV30"][0].get("cvssData", {}).get("baseSeverity", "UNKNOWN")
        
        # Try CVSS v2
        if "cvssMetricV2" in metrics and metrics["cvssMetricV2"]:
            return metrics["cvssMetricV2"][0].get("baseSeverity", "UNKNOWN")
        
        return "UNKNOWN"
    
    def _extract_cvss_score(self, cve: Dict[str, Any]) -> float:
        """Extract CVSS score from CVE data."""
        metrics = cve.get("metrics", {})
        
        # Try CVSS v3.1 first
        if "cvssMetricV31" in metrics and metrics["cvssMetricV31"]:
            score = metrics["cvssMetricV31"][0].get("cvssData", {}).get("baseScore", 0)
            if score:
                return float(score)
        
        # Try CVSS v3.0
        if "cvssMetricV30" in metrics and metrics["cvssMetricV30"]:
            score = metrics["cvssMetricV30"][0].get("cvssData", {}).get("baseScore", 0)
            if score:
                return float(score)
        
        # Try CVSS v2
        if "cvssMetricV2" in metrics and metrics["cvssMetricV2"]:
            score = metrics["cvssMetricV2"][0].get("cvssData", {}).get("baseScore", 0)
            if score:
                return float(score)
        
        return 0.0
    
    def _extract_description(self, cve: Dict[str, Any]) -> str:
        """Extract CVE description."""
        descriptions = cve.get("descriptions", [])
        for desc in descriptions:
            if desc.get("lang") == "en":
                return desc.get("value", "")
        return "No description available"
    
    def _extract_references(self, cve: Dict[str, Any]) -> List[str]:
        """Extract reference URLs."""
        references = cve.get("references", [])
        return [ref.get("url", "") for ref in references if ref.get("url")]
    
    def _generate_summary(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, int]:
        """Generate summary statistics."""
        severity_counts = {
            "CRITICAL": 0,
            "HIGH": 0,
            "MEDIUM": 0,
            "LOW": 0,
            "UNKNOWN": 0
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "UNKNOWN")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        return {
            "critical": severity_counts["CRITICAL"],
            "high": severity_counts["HIGH"],
            "medium": severity_counts["MEDIUM"],
            "low": severity_counts["LOW"],
            "total": len(vulnerabilities)
        }
